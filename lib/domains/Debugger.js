// Generated by CoffeeScript 2.0.0-beta5
var EventEmitter;
EventEmitter = require('events').EventEmitter;
module.exports = function (param$) {
  var debugClient, Debugger, handleBreakEvent;
  debugClient = param$.debugClient;
  Debugger = new EventEmitter;
  handleBreakEvent = function () {
    return debugClient.backtrace({ inlineRefs: true }, function (err, data) {
      var callFrames;
      if (null != err)
        return null;
      callFrames = data.callFrames;
      return Debugger.emit_paused({
        callFrames: callFrames,
        reason: 'other'
      });
    });
  };
  Debugger.causesRecompilation = function (param$1, cb) {
    void 0;
    return cb(null, { result: false });
  };
  Debugger.supportsSeparateScriptCompilationAndExecution = function (param$1, cb) {
    void 0;
    return cb(null, { result: false });
  };
  Debugger.enable = function (param$1, cb) {
    void 0;
    debugClient.on('break', handleBreakEvent);
    return debugClient.scripts({ includeSource: false }, function (err, scripts) {
      var script;
      if (!debugClient.running)
        handleBreakEvent();
      for (var i$ = 0, length$ = scripts.length; i$ < length$; ++i$) {
        script = scripts[i$];
        Debugger.emit_scriptParsed(script);
      }
      return cb();
    });
  };
  Debugger.disable = function (param$1, cb) {
    void 0;
  };
  Debugger.setBreakpointsActive = function (param$1, cb) {
    var active;
    active = param$1.active;
  };
  Debugger.setBreakpointByUrl = function (param$1, cb) {
    var breakpointDesc, cache$, columnNumber, condition, lineNumber, url, urlRegex;
    {
      cache$ = param$1;
      lineNumber = cache$.lineNumber;
      url = cache$.url;
      urlRegex = cache$.urlRegex;
      columnNumber = cache$.columnNumber;
      condition = cache$.condition;
    }
    breakpointDesc = {
      line: lineNumber,
      column: columnNumber,
      condition: condition
    };
    if (null != urlRegex) {
      breakpointDesc.type = 'scriptRegExp';
      breakpointDesc.target = urlRegex;
    } else {
      breakpointDesc.type = 'script';
      breakpointDesc.target = url;
    }
    return debugClient.setbreakpoint(breakpointDesc, function (err, data) {
      if (null != err)
        return cb(err);
      return cb(null, {
        breakpointId: data.breakpoint.toString(),
        locations: data.actual_locations.map(function (l) {
          return {
            scriptId: l.script_id.toString(),
            lineNumber: l.line,
            columnNumber: l.column
          };
        })
      });
    });
  };
  Debugger.setBreakpoint = function (param$1, cb) {
    var cache$, condition, location;
    {
      cache$ = param$1;
      location = cache$.location;
      condition = cache$.condition;
    }
  };
  Debugger.removeBreakpoint = function (param$1, cb) {
    var breakpointId;
    breakpointId = param$1.breakpointId;
    return debugClient.clearbreakpoint({ breakpoint: breakpointId }, function (err, data) {
      return cb();
    });
  };
  Debugger.continueToLocation = function (param$1, cb) {
    var location;
    location = param$1.location;
  };
  Debugger.stepOver = function (param$1, cb) {
    void 0;
    return debugClient['continue']({ stepaction: 'next' }, cb);
  };
  Debugger.stepInto = function (param$1, cb) {
    void 0;
    return debugClient['continue']({ stepaction: 'in' }, cb);
  };
  Debugger.stepOut = function (param$1, cb) {
    void 0;
    return debugClient['continue']({ stepaction: 'out' }, cb);
  };
  Debugger.pause = function (param$1, cb) {
    void 0;
    return debugClient.suspend({}, cb);
  };
  Debugger.resume = function (param$1, cb) {
    void 0;
    return debugClient['continue']({}, cb);
  };
  Debugger.searchInContent = function (param$1, cb) {
    var cache$, caseSensitive, isRegex, query, scriptId;
    {
      cache$ = param$1;
      scriptId = cache$.scriptId;
      query = cache$.query;
      caseSensitive = cache$.caseSensitive;
      isRegex = cache$.isRegex;
    }
  };
  Debugger.canSetScriptSource = function (param$1, cb) {
    void 0;
    return cb(null, { result: true });
  };
  Debugger.setScriptSource = function (param$1, cb) {
    var cache$, preview, scriptId, scriptSource;
    {
      cache$ = param$1;
      scriptId = cache$.scriptId;
      scriptSource = cache$.scriptSource;
      preview = cache$.preview;
    }
  };
  Debugger.restartFrame = function (param$1, cb) {
    var callFrameId;
    callFrameId = param$1.callFrameId;
  };
  Debugger.getScriptSource = function (param$1, cb) {
    var ids, scriptId;
    scriptId = param$1.scriptId;
    ids = [scriptId];
    return debugClient.scripts({
      filter: scriptId,
      includeSource: true
    }, function (err, param$2) {
      var script;
      script = param$2[0];
      return cb(err, script);
    });
  };
  Debugger.getFunctionDetails = function (param$1, cb) {
    var functionId;
    functionId = param$1.functionId;
  };
  Debugger.setPauseOnExceptions = function (param$1, cb) {
    var state;
    state = param$1.state;
  };
  Debugger.evaluateOnCallFrame = function (param$1, cb) {
    var cache$, callFrameId, doNotPauseOnExceptionsAndMuteConsole, expression, generatePreview, includeCommandLineAPI, objectGroup, params, returnByValue;
    {
      cache$ = param$1;
      callFrameId = cache$.callFrameId;
      expression = cache$.expression;
      objectGroup = cache$.objectGroup;
      includeCommandLineAPI = cache$.includeCommandLineAPI;
      doNotPauseOnExceptionsAndMuteConsole = cache$.doNotPauseOnExceptionsAndMuteConsole;
      returnByValue = cache$.returnByValue;
      generatePreview = cache$.generatePreview;
    }
    params = {
      expression: expression,
      global: false,
      frame: callFrameId,
      disable_break: doNotPauseOnExceptionsAndMuteConsole
    };
    return debugClient.evaluate(params, function (err, res) {
      var cache$1, message, stack;
      if (null != err) {
        cache$1 = err;
        message = cache$1.message;
        stack = cache$1.stack;
        return cb(null, {
          result: {
            type: 'string',
            value: message
          },
          wasThrown: true
        });
      } else {
        return cb(null, { result: res });
      }
    });
  };
  Debugger.compileScript = function (param$1, cb) {
    var cache$, expression, sourceURL;
    {
      cache$ = param$1;
      expression = cache$.expression;
      sourceURL = cache$.sourceURL;
    }
  };
  Debugger.runScript = function (param$1, cb) {
    var cache$, contextId, doNotPauseOnExceptionsAndMuteConsole, objectGroup, scriptId;
    {
      cache$ = param$1;
      scriptId = cache$.scriptId;
      contextId = cache$.contextId;
      objectGroup = cache$.objectGroup;
      doNotPauseOnExceptionsAndMuteConsole = cache$.doNotPauseOnExceptionsAndMuteConsole;
    }
  };
  Debugger.setOverlayMessage = function (param$1, cb) {
    var message;
    message = param$1.message;
    return cb();
  };
  Debugger.setVariableValue = function (param$1, cb) {
    var cache$, callFrameId, functionObjectId, newValue, scopeNumber, variableName;
    {
      cache$ = param$1;
      scopeNumber = cache$.scopeNumber;
      variableName = cache$.variableName;
      newValue = cache$.newValue;
      callFrameId = cache$.callFrameId;
      functionObjectId = cache$.functionObjectId;
    }
  };
  Debugger.emit_globalObjectCleared = function (params) {
    var notification;
    notification = {
      params: params,
      method: 'Debugger.globalObjectCleared'
    };
    return this.emit('notification', notification);
  };
  Debugger.emit_scriptParsed = function (params) {
    var notification;
    notification = {
      params: params,
      method: 'Debugger.scriptParsed'
    };
    return this.emit('notification', notification);
  };
  Debugger.emit_scriptFailedToParse = function (params) {
    var notification;
    notification = {
      params: params,
      method: 'Debugger.scriptFailedToParse'
    };
    return this.emit('notification', notification);
  };
  Debugger.emit_breakpointResolved = function (params) {
    var notification;
    notification = {
      params: params,
      method: 'Debugger.breakpointResolved'
    };
    return this.emit('notification', notification);
  };
  Debugger.emit_paused = function (params) {
    var notification;
    notification = {
      params: params,
      method: 'Debugger.paused'
    };
    return this.emit('notification', notification);
  };
  Debugger.emit_resumed = function (params) {
    var notification;
    notification = {
      params: params,
      method: 'Debugger.resumed'
    };
    return this.emit('notification', notification);
  };
  Debugger.BreakpointId = {
    id: 'BreakpointId',
    type: 'string',
    description: 'Breakpoint identifier.'
  };
  Debugger.ScriptId = {
    id: 'ScriptId',
    type: 'string',
    description: 'Unique script identifier.'
  };
  Debugger.CallFrameId = {
    id: 'CallFrameId',
    type: 'string',
    description: 'Call frame identifier.'
  };
  Debugger.Location = {
    id: 'Location',
    type: 'object',
    properties: [
      {
        name: 'scriptId',
        $ref: 'ScriptId',
        description: 'Script identifier as reported in the <code>Debugger.scriptParsed</code>.'
      },
      {
        name: 'lineNumber',
        type: 'integer',
        description: 'Line number in the script.'
      },
      {
        name: 'columnNumber',
        type: 'integer',
        optional: true,
        description: 'Column number in the script.'
      }
    ],
    description: 'Location in the source code.'
  };
  Debugger.FunctionDetails = {
    id: 'FunctionDetails',
    hidden: true,
    type: 'object',
    properties: [
      {
        name: 'location',
        $ref: 'Location',
        description: 'Location of the function.'
      },
      {
        name: 'name',
        type: 'string',
        optional: true,
        description: 'Name of the function. Not present for anonymous functions.'
      },
      {
        name: 'displayName',
        type: 'string',
        optional: true,
        description: "Display name of the function(specified in 'displayName' property on the function object)."
      },
      {
        name: 'inferredName',
        type: 'string',
        optional: true,
        description: 'Name of the function inferred from its initial assignment.'
      },
      {
        name: 'scopeChain',
        type: 'array',
        optional: true,
        items: { $ref: 'Scope' },
        description: 'Scope chain for this closure.'
      }
    ],
    description: 'Information about the function.'
  };
  Debugger.CallFrame = {
    id: 'CallFrame',
    type: 'object',
    properties: [
      {
        name: 'callFrameId',
        $ref: 'CallFrameId',
        description: 'Call frame identifier. This identifier is only valid while the virtual machine is paused.'
      },
      {
        name: 'functionName',
        type: 'string',
        description: 'Name of the JavaScript function called on this call frame.'
      },
      {
        name: 'location',
        $ref: 'Location',
        description: 'Location in the source code.'
      },
      {
        name: 'scopeChain',
        type: 'array',
        items: { $ref: 'Scope' },
        description: 'Scope chain for this call frame.'
      },
      {
        name: 'this',
        $ref: 'Runtime.RemoteObject',
        description: '<code>this</code> object for this call frame.'
      }
    ],
    description: 'JavaScript call frame. Array of call frames form the call stack.'
  };
  Debugger.Scope = {
    id: 'Scope',
    type: 'object',
    properties: [
      {
        name: 'type',
        type: 'string',
        'enum': [
          'global',
          'local',
          'with',
          'closure',
          'catch'
        ],
        description: 'Scope type.'
      },
      {
        name: 'object',
        $ref: 'Runtime.RemoteObject',
        description: 'Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties.'
      }
    ],
    description: 'Scope description.'
  };
  return Debugger;
};
