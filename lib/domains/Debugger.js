// Generated by CoffeeScript 2.0.0-beta7
var EventEmitter, parallel;
EventEmitter = require('events').EventEmitter;
parallel = require('async').parallel;
module.exports = function (param$) {
  var afterCompileQueue, debugClient, Debugger, handleAfterCompile, handleBreakEvent, handleException, nextQueueRun, processCompileQueue, sources;
  debugClient = param$.debugClient;
  Debugger = new EventEmitter;
  sources = {};
  handleBreakEvent = function () {
    var backtrace;
    backtrace = debugClient.commands.backtrace;
    return backtrace({ inlineRefs: true }, function (err, data) {
      var callFrames;
      if (null != err)
        return null;
      callFrames = data.callFrames;
      return Debugger.emit_paused({
        callFrames: callFrames,
        reason: 'other'
      });
    });
  };
  handleException = function (param$1) {
    var backtrace, cache$, exception, uncaught;
    {
      cache$ = param$1;
      exception = cache$.exception;
      uncaught = cache$.uncaught;
    }
    backtrace = debugClient.commands.backtrace;
    return backtrace({ inlineRefs: true }, function (err, data) {
      var callFrames;
      callFrames = null != (null != data ? data.callFrames : void 0) ? null != data ? data.callFrames : void 0 : [];
      return Debugger.emit_paused({
        callFrames: callFrames,
        reason: 'exception',
        data: exception
      });
    });
  };
  afterCompileQueue = [];
  nextQueueRun = null;
  processCompileQueue = function () {
    var params;
    params = {
      ids: afterCompileQueue,
      includeSource: true,
      types: 4
    };
    afterCompileQueue = [];
    nextQueueRun = null;
    return debugClient.commands.scripts(params, function (err, scripts) {
      var script;
      for (var i$ = 0, length$ = scripts.length; i$ < length$; ++i$) {
        script = scripts[i$];
        Debugger.emit_scriptParsed(script);
      }
      return null;
    });
  };
  handleAfterCompile = function (param$1) {
    var script;
    script = param$1.script;
    afterCompileQueue.push(script.id);
    return null != nextQueueRun ? nextQueueRun : nextQueueRun = setTimeout(processCompileQueue, 100);
  };
  Debugger.causesRecompilation = function (param$1, cb) {
    void 0;
    return cb(null, { result: false });
  };
  Debugger.supportsSeparateScriptCompilationAndExecution = function (param$1, cb) {
    void 0;
    return cb(null, { result: false });
  };
  Debugger.enable = function (param$1, cb) {
    void 0;
    debugClient.on('break', handleBreakEvent);
    debugClient.on('exception', handleException);
    debugClient.on('afterCompile', handleAfterCompile);
    return debugClient.commands.scripts({ includeSource: true }, function (err, scripts) {
      var script;
      if (!debugClient.running)
        handleBreakEvent();
      for (var i$ = 0, length$ = scripts.length; i$ < length$; ++i$) {
        script = scripts[i$];
        Debugger.emit_scriptParsed(script);
      }
      return cb();
    });
  };
  Debugger.disable = function (param$1, cb) {
    void 0;
  };
  Debugger.setBreakpointsActive = function (param$1, cb) {
    var active;
    active = param$1.active;
  };
  Debugger.setBreakpointByUrl = function (param$1, cb) {
    var breakpoint, cache$, columnNumber, condition, lineNumber, setbreakpoint, url, urlRegex;
    {
      cache$ = param$1;
      lineNumber = cache$.lineNumber;
      url = cache$.url;
      urlRegex = cache$.urlRegex;
      columnNumber = cache$.columnNumber;
      condition = cache$.condition;
    }
    setbreakpoint = debugClient.commands.setbreakpoint;
    breakpoint = {
      lineNumber: lineNumber,
      url: url,
      urlRegex: urlRegex,
      columnNumber: columnNumber,
      condition: condition
    };
    return setbreakpoint(breakpoint, function (err, breakpointResponse) {
      if (null != err)
        return cb(err);
      return cb(null, breakpointResponse);
    });
  };
  Debugger.setBreakpoint = function (param$1, cb) {
    var cache$, condition, location;
    {
      cache$ = param$1;
      location = cache$.location;
      condition = cache$.condition;
    }
  };
  Debugger.removeBreakpoint = function (param$1, cb) {
    var breakpointId, clearbreakpoint;
    breakpointId = param$1.breakpointId;
    clearbreakpoint = debugClient.commands.clearbreakpoint;
    return clearbreakpoint(breakpointId, function (err, data) {
      return cb(err);
    });
  };
  Debugger.continueToLocation = function (param$1, cb) {
    var location;
    location = param$1.location;
  };
  Debugger.stepOver = function (param$1, cb) {
    void 0;
    return debugClient.commands['continue']('next', function () {
      Debugger.emit_resumed();
      return cb();
    });
  };
  Debugger.stepInto = function (param$1, cb) {
    void 0;
    return debugClient.commands['continue']('in', function () {
      Debugger.emit_resumed();
      return cb();
    });
  };
  Debugger.stepOut = function (param$1, cb) {
    void 0;
    return debugClient.commands['continue']('out', function () {
      Debugger.emit_resumed();
      return cb();
    });
  };
  Debugger.pause = function (param$1, cb) {
    void 0;
    return debugClient.commands.suspend(cb);
  };
  Debugger.resume = function (param$1, cb) {
    void 0;
    return debugClient.commands['continue'](function () {
      Debugger.emit_resumed();
      return cb();
    });
  };
  Debugger.searchInContent = function (param$1, cb) {
    var cache$, caseSensitive, isRegex, query, scriptId;
    {
      cache$ = param$1;
      scriptId = cache$.scriptId;
      query = cache$.query;
      caseSensitive = cache$.caseSensitive;
      isRegex = cache$.isRegex;
    }
  };
  Debugger.canSetScriptSource = function (param$1, cb) {
    void 0;
    return cb(null, { result: true });
  };
  Debugger.setScriptSource = function (param$1, cb) {
    var cache$, changelive, preview, scriptId, scriptSource;
    {
      cache$ = param$1;
      scriptId = cache$.scriptId;
      scriptSource = cache$.scriptSource;
      preview = cache$.preview;
    }
    changelive = debugClient.commands.changelive;
    return changelive({
      scriptId: scriptId,
      scriptSource: scriptSource,
      preview: preview
    }, function (err, summary) {
      var cache$1, change_log, result;
      if (null != err)
        return cb(err);
      sources[scriptId] = scriptSource;
      cache$1 = summary;
      change_log = cache$1.change_log;
      result = cache$1.result;
      if (null != result ? result.stack_modified : void 0)
        handleBreakEvent();
      return cb();
    });
  };
  Debugger.restartFrame = function (param$1, cb) {
    var callFrameId;
    callFrameId = param$1.callFrameId;
  };
  Debugger.getScriptSource = function (param$1, cb) {
    var ids, scriptId;
    scriptId = param$1.scriptId;
    if (null != sources[scriptId])
      return cb(null, { scriptSource: sources[scriptId] });
    ids = [scriptId];
    return debugClient.scripts({
      filter: scriptId,
      includeSource: true
    }, function (err, param$2) {
      var script;
      script = param$2[0];
      return cb(err, script);
    });
  };
  Debugger.getFunctionDetails = function (param$1, cb) {
    var functionId;
    functionId = param$1.functionId;
  };
  Debugger.setPauseOnExceptions = function (param$1, cb) {
    var setexceptionbreak, state, tasks;
    state = param$1.state;
    setexceptionbreak = debugClient.commands.setexceptionbreak;
    tasks = [
      function (cb) {
        return setexceptionbreak({
          type: 'all',
          enabled: state === 'all'
        });
      },
      function (cb) {
        return setexceptionbreak({
          type: 'uncaught',
          enabled: state === 'uncaught'
        });
      }
    ];
    return parallel(tasks, cb);
  };
  Debugger.evaluateOnCallFrame = function (param$1, cb) {
    var cache$, callFrameId, doNotPauseOnExceptionsAndMuteConsole, evaluate, expression, generatePreview, includeCommandLineAPI, objectGroup, objectId, returnByValue;
    {
      cache$ = param$1;
      callFrameId = cache$.callFrameId;
      expression = cache$.expression;
      objectGroup = cache$.objectGroup;
      includeCommandLineAPI = cache$.includeCommandLineAPI;
      doNotPauseOnExceptionsAndMuteConsole = cache$.doNotPauseOnExceptionsAndMuteConsole;
      returnByValue = cache$.returnByValue;
      generatePreview = cache$.generatePreview;
    }
    evaluate = debugClient.commands.evaluate;
    objectId = debugClient.nextObjectId();
    return evaluate({
      doNotPauseOnExceptionsAndMuteConsole: doNotPauseOnExceptionsAndMuteConsole,
      includeCommandLineAPI: includeCommandLineAPI
    }).saveInObjectGroup(objectGroup, objectId).onCallFrame(callFrameId)(expression, function (err, result) {
      if (err) {
        return cb(null, {
          result: err,
          wasThrown: true
        });
      } else {
        return cb(null, {
          result: result,
          wasThrown: false
        });
      }
    });
  };
  Debugger.compileScript = function (param$1, cb) {
    var cache$, expression, sourceURL;
    {
      cache$ = param$1;
      expression = cache$.expression;
      sourceURL = cache$.sourceURL;
    }
  };
  Debugger.runScript = function (param$1, cb) {
    var cache$, contextId, doNotPauseOnExceptionsAndMuteConsole, objectGroup, scriptId;
    {
      cache$ = param$1;
      scriptId = cache$.scriptId;
      contextId = cache$.contextId;
      objectGroup = cache$.objectGroup;
      doNotPauseOnExceptionsAndMuteConsole = cache$.doNotPauseOnExceptionsAndMuteConsole;
    }
  };
  Debugger.setOverlayMessage = function (param$1, cb) {
    var message;
    message = param$1.message;
    return cb();
  };
  Debugger.setVariableValue = function (param$1, cb) {
    var cache$, callFrameId, functionObjectId, newValue, scopeNumber, variableName;
    {
      cache$ = param$1;
      scopeNumber = cache$.scopeNumber;
      variableName = cache$.variableName;
      newValue = cache$.newValue;
      callFrameId = cache$.callFrameId;
      functionObjectId = cache$.functionObjectId;
    }
  };
  Debugger.setAsyncCallStackDepth = function (param$1, cb) {
    var maxDepth;
    maxDepth = param$1.maxDepth;
    return cb(null, { result: true });
  };
  Debugger.emit_globalObjectCleared = function (params) {
    var notification;
    notification = {
      params: params,
      method: 'Debugger.globalObjectCleared'
    };
    return this.emit('notification', notification);
  };
  Debugger.emit_scriptParsed = function (script) {
    var notification;
    if (null != script.scriptSource)
      sources[script.scriptId] = script.scriptSource;
    notification = {
      params: script,
      method: 'Debugger.scriptParsed'
    };
    return this.emit('notification', notification);
  };
  Debugger.emit_scriptFailedToParse = function (params) {
    var notification;
    notification = {
      params: params,
      method: 'Debugger.scriptFailedToParse'
    };
    return this.emit('notification', notification);
  };
  Debugger.emit_breakpointResolved = function (params) {
    var notification;
    notification = {
      params: params,
      method: 'Debugger.breakpointResolved'
    };
    return this.emit('notification', notification);
  };
  Debugger.emit_paused = function (params) {
    var notification;
    notification = {
      params: params,
      method: 'Debugger.paused'
    };
    return this.emit('notification', notification);
  };
  Debugger.emit_resumed = function (params) {
    var notification;
    notification = {
      params: params,
      method: 'Debugger.resumed'
    };
    return this.emit('notification', notification);
  };
  Debugger.BreakpointId = {
    id: 'BreakpointId',
    type: 'string',
    description: 'Breakpoint identifier.'
  };
  Debugger.ScriptId = {
    id: 'ScriptId',
    type: 'string',
    description: 'Unique script identifier.'
  };
  Debugger.CallFrameId = {
    id: 'CallFrameId',
    type: 'string',
    description: 'Call frame identifier.'
  };
  Debugger.Location = {
    id: 'Location',
    type: 'object',
    properties: [
      {
        name: 'scriptId',
        $ref: 'ScriptId',
        description: 'Script identifier as reported in the <code>Debugger.scriptParsed</code>.'
      },
      {
        name: 'lineNumber',
        type: 'integer',
        description: 'Line number in the script.'
      },
      {
        name: 'columnNumber',
        type: 'integer',
        optional: true,
        description: 'Column number in the script.'
      }
    ],
    description: 'Location in the source code.'
  };
  Debugger.FunctionDetails = {
    id: 'FunctionDetails',
    hidden: true,
    type: 'object',
    properties: [
      {
        name: 'location',
        $ref: 'Location',
        description: 'Location of the function.'
      },
      {
        name: 'name',
        type: 'string',
        optional: true,
        description: 'Name of the function. Not present for anonymous functions.'
      },
      {
        name: 'displayName',
        type: 'string',
        optional: true,
        description: "Display name of the function(specified in 'displayName' property on the function object)."
      },
      {
        name: 'inferredName',
        type: 'string',
        optional: true,
        description: 'Name of the function inferred from its initial assignment.'
      },
      {
        name: 'scopeChain',
        type: 'array',
        optional: true,
        items: { $ref: 'Scope' },
        description: 'Scope chain for this closure.'
      }
    ],
    description: 'Information about the function.'
  };
  Debugger.CallFrame = {
    id: 'CallFrame',
    type: 'object',
    properties: [
      {
        name: 'callFrameId',
        $ref: 'CallFrameId',
        description: 'Call frame identifier. This identifier is only valid while the virtual machine is paused.'
      },
      {
        name: 'functionName',
        type: 'string',
        description: 'Name of the JavaScript function called on this call frame.'
      },
      {
        name: 'location',
        $ref: 'Location',
        description: 'Location in the source code.'
      },
      {
        name: 'scopeChain',
        type: 'array',
        items: { $ref: 'Scope' },
        description: 'Scope chain for this call frame.'
      },
      {
        name: 'this',
        $ref: 'Runtime.RemoteObject',
        description: '<code>this</code> object for this call frame.'
      }
    ],
    description: 'JavaScript call frame. Array of call frames form the call stack.'
  };
  Debugger.Scope = {
    id: 'Scope',
    type: 'object',
    properties: [
      {
        name: 'type',
        type: 'string',
        'enum': [
          'global',
          'local',
          'with',
          'closure',
          'catch'
        ],
        description: 'Scope type.'
      },
      {
        name: 'object',
        $ref: 'Runtime.RemoteObject',
        description: 'Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties.'
      }
    ],
    description: 'Scope description.'
  };
  return Debugger;
};
