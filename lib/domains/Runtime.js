// Generated by CoffeeScript 2.0.0-beta5
var EventEmitter, simpleCounter;
EventEmitter = require('events').EventEmitter;
simpleCounter = -5e4;
module.exports = function (param$) {
  var debugClient, getManagedObjectProperties, getObjectGroup, objectGroups, resolveManagedObjectId, Runtime;
  debugClient = param$.debugClient;
  Runtime = new EventEmitter;
  objectGroups = {};
  getObjectGroup = function (name) {
    var getObjectProperties, lastObjectId, objects, properties, registerObject, releaseAll, releaseObject, resolveObjectId;
    if (null != objectGroups[name])
      return objectGroups[name];
    lastObjectId = 0;
    objects = {};
    properties = {};
    registerObject = function (obj, param$1) {
      var cache$, expression, frame, global, objectId;
      {
        cache$ = param$1;
        expression = cache$.expression;
        global = cache$.global;
        frame = cache$.frame;
      }
      if (!(null != obj.objectId))
        return obj;
      objectId = '' + name + '::' + lastObjectId++;
      if (null != global)
        global;
      else
        global = !(null != frame);
      objects[objectId] = {
        expression: expression,
        global: global,
        frame: frame
      };
      obj.objectId = objectId;
      properties[objectId] = null != obj.properties ? obj.properties.map(function (property) {
        var propExpr;
        propExpr = '(' + expression + ')[' + JSON.stringify(property.name) + ']';
        return {
          name: property.name,
          value: registerObject(property.value, {
            global: global,
            frame: frame,
            expression: propExpr
          })
        };
      }) : void 0;
      return obj;
    };
    getObjectProperties = function (objectId) {
      return properties[objectId];
    };
    releaseAll = function () {
      lastObjectId = 0;
      objects = {};
      return properties = {};
    };
    releaseObject = function (objectId) {
      delete objects[objectId];
      return delete properties[objectId];
    };
    resolveObjectId = function (objectId) {
      return objects[objectId];
    };
    return objectGroups[name] = {
      registerObject: registerObject,
      releaseAll: releaseAll,
      releaseObject: releaseObject,
      resolveObjectId: resolveObjectId,
      getObjectProperties: getObjectProperties
    };
  };
  resolveManagedObjectId = function (objectId) {
    var groupName;
    groupName = objectId.split('::')[0];
    return getObjectGroup(groupName).resolveObjectId(objectId);
  };
  getManagedObjectProperties = function (objectId) {
    var groupName;
    groupName = objectId.split('::')[0];
    return getObjectGroup(groupName).getObjectProperties(objectId);
  };
  Runtime.parse = function (param$1, cb) {
    var source;
    source = param$1.source;
  };
  Runtime.evaluate = function (param$1, cb) {
    var cache$, contextId, doNotPauseOnExceptionsAndMuteConsole, expression, generatePreview, includeCommandLineAPI, objectGroup, params, returnByValue;
    {
      cache$ = param$1;
      expression = cache$.expression;
      objectGroup = cache$.objectGroup;
      includeCommandLineAPI = cache$.includeCommandLineAPI;
      doNotPauseOnExceptionsAndMuteConsole = cache$.doNotPauseOnExceptionsAndMuteConsole;
      contextId = cache$.contextId;
      returnByValue = cache$.returnByValue;
      generatePreview = cache$.generatePreview;
    }
    params = {
      objectGroup: objectGroup,
      doNotPauseOnExceptionsAndMuteConsole: doNotPauseOnExceptionsAndMuteConsole
    };
    if (params.objectGroup)
      params.forceObjectId = simpleCounter++;
    return debugClient.commands.evaluate(params)(expression, function (err, res) {
      if (null != err) {
        return cb(null, {
          result: err,
          wasThrown: true
        });
      } else {
        return cb(null, { result: res });
      }
    });
  };
  Runtime.callFunctionOn = function (param$1, cb) {
    var argExpressions, cache$, cache$1, doNotPauseOnExceptionsAndMuteConsole, expression, forceObjectId, functionDeclaration, generatePreview, injectObjects, objectGroup, objectId, params, returnByValue;
    {
      cache$ = param$1;
      objectId = cache$.objectId;
      functionDeclaration = cache$.functionDeclaration;
      doNotPauseOnExceptionsAndMuteConsole = cache$.doNotPauseOnExceptionsAndMuteConsole;
      returnByValue = cache$.returnByValue;
      generatePreview = cache$.generatePreview;
    }
    injectObjects = [];
    argExpressions = [];
    if (objectId === '0') {
      argExpressions.push('this');
    } else if (/^\d+$/.test(objectId)) {
      injectObjects.push({
        name: '$objectCtx',
        objectId: parseInt(objectId)
      });
      argExpressions.push('$objectCtx');
    } else {
      cache$1 = objectId.split(':');
      objectGroup = cache$1[0];
      forceObjectId = cache$1[1];
      argExpressions.push('root.__bugger__[' + JSON.stringify(objectGroup) + '][' + JSON.stringify(forceObjectId) + ']');
    }
    expression = '(' + functionDeclaration + ').call(' + argExpressions.join(', ') + ');';
    params = {
      doNotPauseOnExceptionsAndMuteConsole: doNotPauseOnExceptionsAndMuteConsole,
      generatePreview: generatePreview,
      returnByValue: returnByValue,
      injectObjects: injectObjects
    };
    return debugClient.commands.evaluate(params)(expression, function (err, res) {
      if (null != err) {
        return cb(null, {
          result: err,
          wasThrown: true
        });
      } else {
        return cb(null, { result: res });
      }
    });
  };
  Runtime.getProperties = function (param$1, cb) {
    var cache$, cache$1, cache$2, evaluate, expression, lookup, objectGroup, objectId, options, ownProperties, params, subId;
    {
      cache$ = param$1;
      objectId = cache$.objectId;
      ownProperties = cache$.ownProperties;
    }
    if (objectId.substr(0, 6) === 'scope:' || /^\d+$/.test(objectId)) {
      params = {
        objectId: objectId,
        ownProperties: ownProperties
      };
      return debugClient.commands.lookup(params)(objectId, function (err, objectDescriptor) {
        if (null != err)
          return cb(err);
        return cb(null, { result: objectDescriptor.properties });
      });
    } else {
      cache$1 = objectId.split(':');
      objectGroup = cache$1[0];
      subId = cache$1[1];
      if (null != objectGroup && null != subId) {
        cache$2 = debugClient.commands;
        evaluate = cache$2.evaluate;
        lookup = cache$2.lookup;
        options = {
          returnByValue: true,
          doNotPauseOnExceptionsAndMuteConsole: true
        };
        expression = 'root.__bugger__[' + JSON.stringify(objectGroup) + '][' + JSON.stringify(subId) + ']';
        return evaluate(options)(expression, function (err, remoteObject) {
          if (null != err)
            return cb(err);
          return lookup(options)(remoteObject.objectId, function (err, objectDescriptor) {
            return cb(err, { result: objectDescriptor.properties });
          });
        });
      }
    }
  };
  Runtime.releaseObject = function (param$1, cb) {
    var objectGroup, objectId;
    objectId = param$1.objectId;
    if (0 < objectId.indexOf('::')) {
      objectGroup = objectId.split('::')[0];
      getObjectGroup(objectGroup).releaseObject(objectId);
    }
    return cb();
  };
  Runtime.releaseObjectGroup = function (param$1, cb) {
    var objectGroup;
    objectGroup = param$1.objectGroup;
    getObjectGroup(objectGroup).releaseAll();
    return cb();
  };
  Runtime.run = function (param$1, cb) {
    void 0;
  };
  Runtime.enable = function (param$1, cb) {
    void 0;
  };
  Runtime.disable = function (param$1, cb) {
    void 0;
  };
  Runtime.emit_executionContextCreated = function (params) {
    var notification;
    notification = {
      params: params,
      method: 'Runtime.executionContextCreated'
    };
    return this.emit('notification', notification);
  };
  Runtime.RemoteObjectId = {
    id: 'RemoteObjectId',
    type: 'string',
    description: 'Unique object identifier.'
  };
  Runtime.RemoteObject = {
    id: 'RemoteObject',
    type: 'object',
    description: 'Mirror object referencing original JavaScript object.',
    properties: [
      {
        name: 'type',
        type: 'string',
        'enum': [
          'object',
          'function',
          'undefined',
          'string',
          'number',
          'boolean'
        ],
        description: 'Object type.'
      },
      {
        name: 'subtype',
        type: 'string',
        optional: true,
        'enum': [
          'array',
          'null',
          'node',
          'regexp',
          'date'
        ],
        description: 'Object subtype hint. Specified for <code>object</code> type values only.'
      },
      {
        name: 'className',
        type: 'string',
        optional: true,
        description: 'Object class (constructor) name. Specified for <code>object</code> type values only.'
      },
      {
        name: 'value',
        type: 'any',
        optional: true,
        description: 'Remote object value (in case of primitive values or JSON values if it was requested).'
      },
      {
        name: 'description',
        type: 'string',
        optional: true,
        description: 'String representation of the object.'
      },
      {
        name: 'objectId',
        $ref: 'RemoteObjectId',
        optional: true,
        description: 'Unique object identifier (for non-primitive values).'
      },
      {
        name: 'preview',
        $ref: 'ObjectPreview',
        optional: true,
        description: 'Preview containsing abbreviated property values.',
        hidden: true
      }
    ]
  };
  Runtime.ObjectPreview = {
    id: 'ObjectPreview',
    type: 'object',
    hidden: true,
    description: 'Object containing abbreviated remote object value.',
    properties: [
      {
        name: 'lossless',
        type: 'boolean',
        description: 'Determines whether preview is lossless (contains all information of the original object).'
      },
      {
        name: 'overflow',
        type: 'boolean',
        description: 'True iff some of the properties of the original did not fit.'
      },
      {
        name: 'properties',
        type: 'array',
        items: { $ref: 'PropertyPreview' },
        description: 'List of the properties.'
      }
    ]
  };
  Runtime.PropertyPreview = {
    id: 'PropertyPreview',
    type: 'object',
    hidden: true,
    properties: [
      {
        name: 'name',
        type: 'string',
        description: 'Property name.'
      },
      {
        name: 'type',
        type: 'string',
        'enum': [
          'object',
          'function',
          'undefined',
          'string',
          'number',
          'boolean'
        ],
        description: 'Object type.'
      },
      {
        name: 'value',
        type: 'string',
        optional: true,
        description: 'User-friendly property value string.'
      },
      {
        name: 'valuePreview',
        $ref: 'ObjectPreview',
        optional: true,
        description: 'Nested value preview.'
      },
      {
        name: 'subtype',
        type: 'string',
        optional: true,
        'enum': [
          'array',
          'null',
          'node',
          'regexp',
          'date'
        ],
        description: 'Object subtype hint. Specified for <code>object</code> type values only.'
      }
    ]
  };
  Runtime.PropertyDescriptor = {
    id: 'PropertyDescriptor',
    type: 'object',
    description: 'Object property descriptor.',
    properties: [
      {
        name: 'name',
        type: 'string',
        description: 'Property name.'
      },
      {
        name: 'value',
        $ref: 'RemoteObject',
        optional: true,
        description: 'The value associated with the property.'
      },
      {
        name: 'writable',
        type: 'boolean',
        optional: true,
        description: 'True if the value associated with the property may be changed (data descriptors only).'
      },
      {
        name: 'get',
        $ref: 'RemoteObject',
        optional: true,
        description: 'A function which serves as a getter for the property, or <code>undefined</code> if there is no getter (accessor descriptors only).'
      },
      {
        name: 'set',
        $ref: 'RemoteObject',
        optional: true,
        description: 'A function which serves as a setter for the property, or <code>undefined</code> if there is no setter (accessor descriptors only).'
      },
      {
        name: 'configurable',
        type: 'boolean',
        description: 'True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.'
      },
      {
        name: 'enumerable',
        type: 'boolean',
        description: 'True if this property shows up during enumeration of the properties on the corresponding object.'
      },
      {
        name: 'wasThrown',
        type: 'boolean',
        optional: true,
        description: 'True if the result was thrown during the evaluation.'
      },
      {
        name: 'isOwn',
        optional: true,
        type: 'boolean',
        description: 'True if the property is owned for the object.',
        hidden: true
      }
    ]
  };
  Runtime.InternalPropertyDescriptor = {
    id: 'InternalPropertyDescriptor',
    type: 'object',
    description: "Object internal property descriptor. This property isn't normally visible in JavaScript code.",
    properties: [
      {
        name: 'name',
        type: 'string',
        description: 'Conventional property name.'
      },
      {
        name: 'value',
        $ref: 'RemoteObject',
        optional: true,
        description: 'The value associated with the property.'
      }
    ],
    hidden: true
  };
  Runtime.CallArgument = {
    id: 'CallArgument',
    type: 'object',
    description: 'Represents function call argument. Either remote object id <code>objectId</code> or primitive <code>value</code> or neither of (for undefined) them should be specified.',
    properties: [
      {
        name: 'value',
        type: 'any',
        optional: true,
        description: 'Primitive value.'
      },
      {
        name: 'objectId',
        $ref: 'RemoteObjectId',
        optional: true,
        description: 'Remote object handle.'
      }
    ]
  };
  Runtime.ExecutionContextId = {
    id: 'ExecutionContextId',
    type: 'integer',
    description: 'Id of an execution context.'
  };
  Runtime.ExecutionContextDescription = {
    id: 'ExecutionContextDescription',
    type: 'object',
    description: 'Description of an isolated world.',
    properties: [
      {
        name: 'id',
        $ref: 'ExecutionContextId',
        description: 'Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed.'
      },
      {
        name: 'isPageContext',
        type: 'boolean',
        description: 'True if this is a context where inpspected web page scripts run. False if it is a content script isolated context.',
        hidden: true
      },
      {
        name: 'name',
        type: 'string',
        description: 'Human readable name describing given context.',
        hidden: true
      },
      {
        name: 'frameId',
        $ref: 'Network.FrameId',
        description: 'Id of the owning frame.'
      }
    ]
  };
  Runtime.SyntaxErrorType = {
    id: 'SyntaxErrorType',
    type: 'string',
    'enum': [
      'none',
      'irrecoverable',
      'unterminated-literal',
      'recoverable'
    ],
    description: 'Syntax error type: "none" for no error, "irrecoverable" for unrecoverable errors, "unterminated-literal" for when there is an unterminated literal, "recoverable" for when the expression is unfinished but valid so far.'
  };
  Runtime.ErrorRange = {
    id: 'ErrorRange',
    type: 'object',
    description: 'Range of an error in source code.',
    properties: [
      {
        name: 'startOffset',
        type: 'integer',
        description: 'Start offset of range (inclusive).'
      },
      {
        name: 'endOffset',
        type: 'integer',
        description: 'End offset of range (exclusive).'
      }
    ]
  };
  return Runtime;
};
