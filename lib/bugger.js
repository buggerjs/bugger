// Generated by CoffeeScript 2.0.0-beta6
var bugger, bugScript, domains, EventEmitter, inspectorServer, omit, parallel;
EventEmitter = require('events').EventEmitter;
parallel = require('async').parallel;
omit = require('underscore').omit;
bugScript = require('./bug-script');
domains = require('./domains');
inspectorServer = require('./inspector');
bugger = function (debugBreak, webport, webhost, hang, stfu, language) {
  var buggerLog, forwardErrors, run, startScript, startServer, wire, wireStdIO, wrapEmitter;
  if (null == debugBreak)
    debugBreak = true;
  if (null == webport)
    webport = 8058;
  if (null == webhost)
    webhost = '127.0.0.1';
  if (null == hang)
    hang = true;
  if (null == stfu)
    stfu = false;
  if (null == language)
    language = null;
  buggerLog = stfu ? function () {
  } : function (message) {
    return console.error(message);
  };
  startServer = function (cb) {
    var inspector;
    inspector = inspectorServer();
    return inspector.listen(webport, webhost, function () {
      return cb(null, inspector);
    });
  };
  wrapEmitter = new EventEmitter;
  forwardErrors = function (internalObjects) {
    internalObjects = 1 <= arguments.length ? [].slice.call(arguments, 0) : [];
    return function (accum$) {
      var internalObj;
      for (var i$ = 0, length$ = internalObjects.length; i$ < length$; ++i$) {
        internalObj = internalObjects[i$];
        accum$.push(internalObj.on('error', function (err) {
          return wrapEmitter.emit('error', err);
        }));
      }
      return accum$;
    }.call(this, []);
  };
  startScript = function (script, scriptArgs, options) {
    return function (cb) {
      return bugScript(script, scriptArgs, options, cb);
    };
  };
  wireStdIO = function (forked) {
    forked.stdout.pipe(process.stdout);
    forked.stderr.pipe(process.stderr);
    return process.stdin.pipe(forked.stdin);
  };
  wire = function (param$) {
    var cache$, debugClient, forked, inspector;
    {
      cache$ = param$;
      inspector = cache$.inspector;
      forked = cache$.forked;
      debugClient = cache$.debugClient;
      domains = cache$.domains;
    }
    wireStdIO(forked);
    forwardErrors(debugClient, domains, forked, inspector);
    domains.load({
      debugClient: debugClient,
      forked: forked
    });
    inspector.on('request', domains.handle);
    domains.on('notification', inspector.dispatchEvent);
    forked.on('exit', function (exitCode) {
      if (hang) {
        return buggerLog('[bugger] Process exit with status ' + exitCode);
      } else {
        return process.exit(exitCode);
      }
    });
    return forked.on('message', function (message) {
      var method, params;
      if (null != message.method) {
        method = message.method;
        params = omit(message, 'method');
        return domains.handle({
          method: method,
          params: params
        });
      }
    });
  };
  wrapEmitter.run = run = function (script, scriptArgs) {
    var tasks;
    if (null == scriptArgs)
      scriptArgs = [];
    tasks = [
      startServer,
      startScript(script, scriptArgs, {
        debugBreak: debugBreak,
        language: language
      })
    ];
    return parallel(tasks, function (err, param$) {
      var cache$, forked, inspector;
      {
        cache$ = param$;
        inspector = cache$[0];
        forked = cache$[1];
      }
      if (null != err)
        throw err;
      return forked.on('debugClient', function (debugClient) {
        var argString;
        wire({
          inspector: inspector,
          forked: forked,
          debugClient: debugClient,
          domains: domains
        });
        argString = scriptArgs.map(function (arg) {
          return JSON.stringify(arg);
        }).join(' ');
        buggerLog('[bugger] Debugging ' + script + ' ' + argString);
        return buggerLog('[bugger] ' + inspector.DEFAULT_URL);
      });
    });
  };
  return wrapEmitter;
};
module.exports = bugger;
if (!(null != module.parent))
  bugger().run('examples/simple.js');
