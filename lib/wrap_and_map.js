// Generated by CoffeeScript 2.0.0-beta4
var _, expressionToHandle, handleToExpression, knownExpressions, knownExpressionsRev, lastHandle, makePropertyHandle, refToObject, throwErr, toJSONValue, wrapperObject;
_ = require('underscore');
throwErr = function (cb, msg) {
  return cb(null, {
    type: 'string',
    value: msg
  }, true);
};
lastHandle = 0;
knownExpressions = {};
knownExpressionsRev = {};
expressionToHandle = function (expression) {
  if (!knownExpressions[expression]) {
    knownExpressions[expression] = ++lastHandle;
    knownExpressionsRev[lastHandle.toString()] = expression;
  }
  return '_' + knownExpressions[expression];
};
handleToExpression = function (handle) {
  return knownExpressionsRev[handle.substr(1)];
};
makePropertyHandle = function (parentHandle, propertyName) {
  var parentExpression, propertyExpression;
  parentExpression = handleToExpression(parentHandle);
  propertyExpression = parentExpression + ('[' + JSON.stringify(propertyName) + ']');
  return expressionToHandle(propertyExpression);
};
refToObject = function (ref, frame, scope) {
  var desc, kids, name, subtype;
  if (null == frame)
    frame = 0;
  if (null == scope)
    scope = 0;
  desc = '';
  name = null;
  subtype = null;
  kids = ref.properties ? ref.properties.length : false;
  switch (ref.type) {
  case 'object':
    name = /#<(\w+)>/.exec(ref.text);
    if ((null != name ? name.length : void 0) > 1) {
      desc = name[1];
      if (desc === 'Array') {
        subtype = 'array';
        desc += '[' + (ref.properties.length - 1) + ']';
      } else if (desc === 'Buffer') {
        desc += '[' + (ref.properties.length - 4) + ']';
      }
    } else {
      desc = null != ref.className ? ref.className : 'Object';
    }
    break;
  case 'function':
    desc = null != ref.text ? ref.text : 'function()';
    break;
  default:
    desc = null != ref.text ? ref.text : '';
  }
  if (desc.length > 100)
    desc = desc.substring(0, 100) + '\u2026';
  return wrapperObject(ref.type, desc, kids, frame, scope, ref.handle, subtype);
};
wrapperObject = function (type, description, hasChildren, frame, scope, ref, subtype) {
  return {
    type: type,
    subtype: subtype,
    description: description,
    hasChildren: type === 'function' || type === 'object',
    objectId: type === 'function' || type === 'object' ? '' + frame + ':' + scope + ':' + ref : null
  };
};
toJSONValue = function (objInfo, refs) {
  var constructorFunction, properties, protoObject, prototypeObject, refMap;
  refMap = {};
  refs.forEach(function (ref) {
    return refMap[ref.handle] = ref;
  });
  switch (objInfo.type) {
  case 'object':
    constructorFunction = refMap[objInfo.constructorFunction.ref];
    prototypeObject = refMap[objInfo.prototypeObject.ref];
    protoObject = refMap[objInfo.protoObject.ref];
    properties = {};
    objInfo.properties.forEach(function (prop) {
      var propObjInfo;
      propObjInfo = _.defaults({ handle: makePropertyHandle(objInfo.handle, prop.name) }, refMap[prop.ref]);
      return properties[prop.name] = toJSONValue(propObjInfo, refs);
    });
    return properties;
  case 'boolean':
    return objInfo.value;
  default: {
      console.error('Unknown type: ', objInfo);
      return null;
    }
  }
};
module.exports = {
  toJSONValue: toJSONValue,
  wrapperObject: wrapperObject,
  throwErr: throwErr,
  expressionToHandle: expressionToHandle,
  handleToExpression: handleToExpression,
  refToObject: refToObject,
  makePropertyHandle: makePropertyHandle
};
