// Generated by CoffeeScript 2.0.0-beta7
var load, TimelineProbe;
TimelineProbe = function () {
  var __clearInterval, __clearTimeout, __setInterval, __setTimeout, __time, __timeEnd, knownTimers, nextTimerId, parseStackTrace, timeoutEval, toTimeline;
  toTimeline = require('./to_timeline');
  parseStackTrace = toTimeline.parseStackTrace;
  nextTimerId = 1;
  knownTimers = {};
  console.timeStamp = function (message) {
    if (null == message)
      message = 'console.timeStamp';
    return toTimeline('TimeStamp', { data: { message: message } });
  };
  __time = console.time;
  console.time = function (message) {
    toTimeline('Time', { data: { message: message } });
    return __time.apply(console, arguments);
  };
  __timeEnd = console.timeEnd;
  console.timeEnd = function (message) {
    toTimeline('TimeEnd', { data: { message: message } });
    return __timeEnd.apply(console, arguments);
  };
  timeoutEval = function (self, fn, params) {
    if ('string' === typeof fn) {
      return eval(fn);
    } else {
      return fn.apply(self, params);
    }
  };
  __setTimeout = root.setTimeout;
  root.setTimeout = function (fn, timeout, params) {
    var timerHandle, timerId, wrapFn;
    params = 3 <= arguments.length ? [].slice.call(arguments, 2) : [];
    timerId = (nextTimerId++).toString();
    wrapFn = function () {
      toTimeline('TimerFire', { data: { timerId: timerId } });
      delete knownTimers[timerId];
      return timeoutEval(this, fn, arguments);
    };
    timerHandle = __setTimeout.call.apply(__setTimeout, [
      root,
      wrapFn,
      timeout
    ].concat([].slice.call(params)));
    knownTimers[timerId] = timerHandle;
    toTimeline('TimerInstall', {
      data: {
        timeout: timeout,
        timerId: timerId,
        singleShot: true
      }
    });
    return timerHandle;
  };
  __clearTimeout = root.clearTimeout;
  root.clearTimeout = function (timerHandle) {
    var handle, id, timerId;
    timerId = null;
    for (id in knownTimers) {
      handle = knownTimers[id];
      if (handle === timerHandle) {
        timerId = id;
        break;
      }
    }
    if (null != timerId) {
      delete knownTimers[timerId];
      toTimeline('TimerRemove', {
        data: {
          timerId: timerId,
          timeout: timerHandle._idleTimeout
        }
      });
    }
    return __clearTimeout.call(root, timerHandle);
  };
  __setInterval = root.setInterval;
  root.setInterval = function (fn, timeout, params) {
    var timerHandle, timerId, wrapFn;
    params = 3 <= arguments.length ? [].slice.call(arguments, 2) : [];
    timerId = (nextTimerId++).toString();
    wrapFn = function () {
      toTimeline('TimerFire', { data: { timerId: timerId } });
      return timeoutEval(this, fn, arguments);
    };
    timerHandle = __setInterval.call.apply(__setInterval, [
      root,
      wrapFn,
      timeout
    ].concat([].slice.call(params)));
    knownTimers[timerId] = timerHandle;
    toTimeline('TimerInstall', {
      data: {
        timeout: timeout,
        timerId: timerId,
        singleShot: false
      }
    });
    return timerHandle;
  };
  __clearInterval = root.clearInterval;
  return root.clearInterval = function (timerHandle) {
    var handle, id, timerId;
    timerId = null;
    for (id in knownTimers) {
      handle = knownTimers[id];
      if (handle === timerHandle) {
        timerId = id;
        break;
      }
    }
    if (null != timerId)
      toTimeline('TimerRemove', {
        data: {
          timerId: timerId,
          timeout: timerHandle._idleTimeout
        }
      });
    return __clearInterval.call(root, timerHandle);
  };
};
load = function (scriptContext, safe) {
  var Timeline;
  if (null == safe)
    safe = false;
  if (safe)
    return;
  return Timeline = TimelineProbe();
};
module.exports = { load: load };
