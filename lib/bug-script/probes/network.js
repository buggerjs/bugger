// Generated by CoffeeScript 2.0.0-beta5
var _, _renderHeaders, http, https, lastRequestId, load, makeStackTrace, mimeTypeToResponseType, patchProtocolLib, removeArraysFromHeaders, sendMessage, url;
http = require('http');
https = require('https');
url = require('url');
_ = require('underscore');
lastRequestId = 0;
mimeTypeToResponseType = function (mimeType) {
  if (mimeType.indexOf('html') >= 0) {
    return 'Document';
  } else if (mimeType.indexOf('json') >= 0 || mimeType.indexOf('xml') >= 0) {
    return 'XHR';
  } else if (mimeType.indexOf('css') >= 0) {
    return 'Stylesheet';
  } else if (mimeType.indexOf('javascript') >= 0) {
    return 'Script';
  } else if (mimeType.indexOf('image') >= 0) {
    return 'Image';
  } else {
    return 'Other';
  }
};
sendMessage = function (method, params) {
  var message;
  message = _.extend({
    method: method,
    timestamp: new Date().getTime() / 1e3
  }, params);
  if (process.send)
    return process.send(message);
};
removeArraysFromHeaders = function (headers) {
  var headerMap, headerName, headerValue;
  headerMap = {};
  for (headerName in headers) {
    headerValue = headers[headerName];
    headerMap[headerName] = Array.isArray(headerValue) ? headerValue.join('\n') : headerValue;
  }
  return headerMap;
};
makeStackTrace = function () {
  var err, orig, stack;
  orig = Error.prepareStackTrace;
  Error.prepareStackTrace = function (_, stack) {
    return stack;
  };
  err = new Error;
  Error.captureStackTrace(err, arguments.callee);
  stack = err.stack;
  Error.prepareStackTrace = orig;
  return stack.map(function (frame) {
    return {
      url: frame.getFileName(),
      functionName: frame.getFunctionName(),
      lineNumber: frame.getLineNumber(),
      columnNumber: frame.getColumnNumber()
    };
  });
};
_renderHeaders = function () {
  var headers, headerValue, key;
  if (!this._headers)
    return {};
  headers = {};
  for (key in this._headers) {
    headerValue = this._headers[key];
    headers[this._headerNames[key]] = headerValue;
  }
  return headers;
};
patchProtocolLib = function (protocolLib) {
  var oldRequest;
  oldRequest = protocolLib.request;
  return protocolLib.request = function (options, cb) {
    var documentURL, loaderId, patchedClientRequest, patchedClientResponseCallback, requestId;
    if (typeof options === 'string')
      options = url.parse(options);
    requestId = (++lastRequestId).toString();
    loaderId = requestId;
    documentURL = url.format(null != options.uri ? options.uri : options);
    patchedClientRequest = function (cReq) {
      var _end, cReqStartTime;
      cReq.on('error', function (err) {
        return sendMessage('Network.emit_loadingFailed', {
          requestId: requestId,
          errorText: err.message
        });
      });
      _end = cReq.end;
      cReqStartTime = Date.now();
      cReq.end = function () {
        var initiator, request, stackTrace;
        request = {
          headers: _renderHeaders.apply(cReq),
          method: cReq.method,
          postData: '',
          url: documentURL
        };
        stackTrace = makeStackTrace();
        initiator = {
          stackTrace: stackTrace,
          type: 'script'
        };
        sendMessage('Network.emit_requestWillBeSent', {
          requestId: requestId,
          loaderId: loaderId,
          documentURL: documentURL,
          request: request,
          stackTrace: stackTrace,
          initiator: initiator
        });
        sendMessage('Timeline.emit_eventRecorded', {
          record: {
            type: 'ResourceSendRequest',
            startTime: cReqStartTime,
            endTime: Date.now(),
            data: {
              requestId: requestId,
              url: documentURL,
              requestMethod: cReq.method
            }
          }
        });
        return _end.apply(this, arguments);
      };
      return cReq;
    };
    patchedClientResponseCallback = function (cb) {
      return function (cRes) {
        var cache$, cResStartTime, mimeType, response, type;
        mimeType = (cache$ = null != cRes.headers['content-type'] ? cRes.headers['content-type'].split(';')[0] : void 0, null != cache$ ? cache$ : 'text/plain');
        type = mimeTypeToResponseType(mimeType);
        cResStartTime = Date.now();
        response = {
          connectionId: requestId,
          connectionReused: false,
          headers: removeArraysFromHeaders(cRes.headers),
          mimeType: mimeType,
          status: cRes.statusCode,
          statusText: http.STATUS_CODES[cRes.statusCode],
          url: documentURL
        };
        sendMessage('Network.emit_responseReceived', {
          requestId: requestId,
          loaderId: loaderId,
          response: response,
          type: type
        });
        cRes.on('data', function (chunk) {
          process.send({
            method: 'Network._cacheResponseContent',
            requestId: requestId,
            chunk: chunk.toString()
          });
          return sendMessage('Network.emit_dataReceived', {
            requestId: requestId,
            dataLength: chunk.length,
            encodedDataLength: chunk.length
          });
        });
        cRes.on('end', function () {
          sendMessage('Network.emit_loadingFinished', { requestId: requestId });
          return sendMessage('Timeline.emit_eventRecorded', {
            record: {
              type: 'ResourceReceiveResponse',
              startTime: cResStartTime,
              endTime: Date.now(),
              data: {
                requestId: requestId,
                mimeType: mimeType,
                statusCode: cRes.statusCode
              }
            }
          });
        });
        cRes.on('error', function (err) {
          sendMessage('Network.emit_loadingFailed', {
            requestId: requestId,
            errorText: err.message
          });
          return sendMessage('Timeline.emit_eventRecorded', {
            record: {
              type: 'ResourceReceiveResponse',
              startTime: cResStartTime,
              endTime: Date.now(),
              data: {
                requestId: requestId,
                mimeType: mimeType,
                statusCode: cRes.statusCode
              }
            }
          });
        });
        return cb(cRes);
      };
    };
    return patchedClientRequest(oldRequest(options, patchedClientResponseCallback(cb)));
  };
};
load = function (scriptContext, safe) {
  if (null == safe)
    safe = false;
  if (safe)
    return;
  return function (accum$) {
    var protocolLib;
    for (var cache$ = [
          http,
          https
        ], i$ = 0, length$ = cache$.length; i$ < length$; ++i$) {
      protocolLib = cache$[i$];
      accum$.push(patchProtocolLib(protocolLib));
    }
    return accum$;
  }.call(this, []);
};
module.exports = { load: load };
