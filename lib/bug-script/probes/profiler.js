// Generated by CoffeeScript 2.0.0-beta7
var load, ProfilerProbe;
ProfilerProbe = function () {
  var CPUProfileType, HeapProfiler, HeapProfileType, isSampling, Profiler, profilesByType, profileStarts, v8profiler;
  v8profiler = require('v8-profiler');
  Profiler = {};
  HeapProfiler = {};
  profileStarts = {};
  isSampling = false;
  profilesByType = {
    HEAP: {},
    CPU: {}
  };
  HeapProfileType = 'HEAP';
  CPUProfileType = 'CPU';
  Profiler.isSampling = function (param$, cb) {
    void 0;
    return cb(null, { result: isSampling });
  };
  Profiler.enable = function (param$, cb) {
    void 0;
    return cb();
  };
  Profiler.disable = function (param$, cb) {
    void 0;
    return cb();
  };
  Profiler.start = function (param$, cb) {
    var name;
    name = param$.name;
    if (null != name)
      name;
    else
      name = '';
    profileStarts[name] = Date.now() / 1e3;
    v8profiler.startProfiling(name);
    isSampling = true;
    process.send({
      method: 'Profiler.emit_setRecordingProfile',
      isProfiling: true
    });
    return cb();
  };
  Profiler.stop = function (param$, cb) {
    var name, profile;
    name = param$.name;
    if (null != name)
      name;
    else
      name = '';
    isSampling = false;
    profile = v8profiler.stopProfiling(name);
    profile.startTime = profileStarts[name];
    delete profileStarts[name];
    profile.endTime = Date.now() / 1e3;
    profilesByType[CPUProfileType][profile.uid] = profile;
    process.send({
      method: 'Profiler.emit_addProfileHeader',
      header: {
        title: profile.title,
        uid: profile.uid,
        typeId: CPUProfileType
      }
    });
    process.send({
      method: 'Profiler.emit_setRecordingProfile',
      isProfiling: false
    });
    return cb();
  };
  HeapProfiler.getProfileHeaders = function (param$, cb) {
    var headers, profile, profileId;
    void 0;
    headers = [];
    for (profileId in profilesByType[HeapProfileType]) {
      profile = profilesByType[HeapProfileType][profileId];
      headers.push({
        title: profile.title,
        uid: profile.uid,
        typeId: HeapProfileType
      });
    }
    return cb(null, { headers: headers });
  };
  Profiler.getProfileHeaders = function (param$, cb) {
    var headers, profile, profileId;
    void 0;
    headers = [];
    for (profileId in profilesByType[CPUProfileType]) {
      profile = profilesByType[CPUProfileType][profileId];
      headers.push({
        title: profile.title,
        uid: profile.uid,
        typeId: CPUProfileType
      });
    }
    return cb(null, { headers: headers });
  };
  Profiler.getCPUProfile = function (param$, cb) {
    var profile, uid, withHitCounts;
    uid = param$.uid;
    profile = profilesByType[CPUProfileType][uid];
    profile.typeId = CPUProfileType;
    withHitCounts = function (node) {
      var child;
      node.hitCount = node.selfTime;
      for (var i$ = 0, length$ = node.children.length; i$ < length$; ++i$) {
        child = node.children[i$];
        withHitCounts(child);
      }
      return node;
    };
    return cb(null, {
      profile: {
        title: profile.title,
        uid: profile.uid,
        typeId: CPUProfileType,
        head: withHitCounts(profile.getTopDownRoot()),
        bottomUpHead: withHitCounts(profile.getBottomUpRoot()),
        startTime: profile.startTime,
        endTime: profile.endTime
      }
    });
  };
  HeapProfiler.getHeapSnapshot = function (param$, cb) {
    var chunks, onData, onEnd, snapshot, uid;
    uid = param$.uid;
    snapshot = profilesByType[HeapProfileType][uid];
    chunks = [];
    onData = function (chunk, size) {
      return chunks.push(chunk.toString());
    };
    onEnd = function () {
      var chunk;
      for (var i$ = 0, length$ = chunks.length; i$ < length$; ++i$) {
        chunk = chunks[i$];
        process.send({
          method: 'HeapProfiler.emit_addHeapSnapshotChunk',
          uid: snapshot.uid,
          chunk: chunk
        });
      }
      process.send({
        method: 'HeapProfiler.emit_finishHeapSnapshot',
        uid: snapshot.uid
      });
      return cb(null, {
        profile: {
          title: snapshot.title,
          uid: snapshot.uid,
          typeId: HeapProfileType
        }
      });
    };
    return snapshot.serialize({
      onData: onData,
      onEnd: onEnd
    });
  };
  Profiler.getHeapSnapshot = function (param$, cb) {
    var uid;
    uid = param$.uid;
  };
  HeapProfiler.removeProfile = function (param$, cb) {
    var uid;
    uid = param$.uid;
    if (null != profilesByType[HeapProfileType][uid])
      delete profilesByType[HeapProfileType][uid];
    return cb();
  };
  HeapProfiler.clearProfiles = function (param$, cb) {
    void 0;
    profilesByType.HEAP = {};
    return v8profiler.deleteAllSnapshots();
  };
  Profiler.removeProfile = function (param$, cb) {
    var cache$, type, uid;
    {
      cache$ = param$;
      type = cache$.type;
      uid = cache$.uid;
    }
    if (null != profilesByType[type][uid])
      delete profilesByType[type][uid];
    return cb();
  };
  Profiler.clearProfiles = function (param$, cb) {
    void 0;
    profilesByType.CPU = {};
    v8profiler.deleteAllProfiles();
    return cb();
  };
  HeapProfiler.takeHeapSnapshot = function (param$, cb) {
    var reportProgress, snapshot;
    reportProgress = param$.reportProgress;
    snapshot = v8profiler.takeSnapshot(function (done, total) {
      var method;
      method = 'HeapProfiler.emit_reportHeapSnapshotProgress';
      return process.send({
        method: method,
        done: done,
        total: total
      });
    });
    profilesByType[HeapProfileType][snapshot.uid] = snapshot;
    process.send({
      method: 'HeapProfiler.emit_addProfileHeader',
      header: {
        title: snapshot.title,
        uid: snapshot.uid,
        typeId: HeapProfileType
      }
    });
    return cb();
  };
  Profiler.takeHeapSnapshot = function (param$, cb) {
    var reportProgress;
    reportProgress = param$.reportProgress;
  };
  Profiler.getObjectByHeapObjectId = function (param$, cb) {
    var cache$, objectGroup, objectId;
    {
      cache$ = param$;
      objectId = cache$.objectId;
      objectGroup = cache$.objectGroup;
    }
  };
  Profiler.getHeapObjectId = function (param$, cb) {
    var objectId;
    objectId = param$.objectId;
  };
  return {
    Profiler: Profiler,
    HeapProfiler: HeapProfiler
  };
};
load = function (scriptContext, safe) {
  var agents;
  if (null == safe)
    safe = false;
  if (safe)
    return;
  agents = ProfilerProbe();
  if (null != root.profile)
    root.profile;
  else
    root.profile = null != console.profile ? console.profile : console.profile = function (name) {
      return agents.Profiler.start({ name: name }, function () {
      });
    };
  if (null != root.profileEnd)
    root.profileEnd;
  else
    root.profileEnd = null != console.profileEnd ? console.profileEnd : console.profileEnd = function (name) {
      return agents.Profiler.stop({ name: name }, function () {
      });
    };
  return process.on('message', function (message) {
    var cache$, cache$1, cache$2, command, domain, method, seq;
    if (message.type === 'forward_req') {
      cache$ = message;
      command = cache$.command;
      seq = cache$.seq;
      cache$1 = command.split('.');
      domain = cache$1[0];
      method = cache$1[1];
      if (!(domain === 'Profiler' || domain === 'HeapProfiler'))
        return;
      cache$2 = message.command.split('.');
      domain = cache$2[0];
      method = cache$2[1];
      return agents[domain][method](message.params, function (err, data) {
        var response;
        response = {
          command: command,
          request_seq: seq,
          type: 'forward_res'
        };
        if (null != err) {
          response.error = {
            message: err.message,
            code: err.code,
            type: err.type
          };
        } else {
          response.data = data;
        }
        return process.send(response);
      });
    }
  });
};
module.exports = { load: load };
