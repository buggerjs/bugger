// Generated by CoffeeScript 2.0.0-beta5
var callbackWrapper, debugClient, debugParser, defaults, EventEmitter, mapFrame, mapScope, mapScript, mapValue, NEXT_SEQ, series;
EventEmitter = require('events').EventEmitter;
defaults = require('underscore').defaults;
series = require('async').series;
mapValue = require('./map/value');
mapScope = require('./map/scope');
mapFrame = require('./map/frame');
mapScript = require('./map/script');
NEXT_SEQ = 0;
debugParser = function (stream) {
  var buffer, currentMessage, emitter, emptyMessage, parseBody, parseBuffer, parseHeaders;
  buffer = '';
  emitter = new EventEmitter;
  emptyMessage = function () {
    return {
      headers: null,
      contentLength: 0
    };
  };
  currentMessage = emptyMessage();
  parseHeaders = function () {
    var contentLengthMatch, offset;
    offset = buffer.indexOf('\r\n\r\n');
    if (!(offset > 0))
      return false;
    currentMessage.headers = buffer.substr(0, offset + 4);
    contentLengthMatch = /Content-Length: (\d+)/.exec(currentMessage.headers);
    if (contentLengthMatch[1]) {
      currentMessage.contentLength = parseInt(contentLengthMatch[1], 10);
    } else {
      emitter.emit('error', new Error('No Content-Length'));
    }
    buffer = buffer.substr(offset + 4);
    return true;
  };
  parseBody = function () {
    var b, body, contentLength, error, obj;
    contentLength = currentMessage.contentLength;
    if (!(Buffer.byteLength(buffer) >= contentLength))
      return false;
    b = new Buffer(buffer);
    body = b.toString('utf8', 0, currentMessage.contentLength);
    buffer = b.toString('utf8', currentMessage.contentLength, b.length);
    if (body.length > 0)
      try {
        obj = JSON.parse(body);
        emitter.emit('parsed:' + obj.type, obj);
      } catch (e$) {
        error = e$;
        emitter.emit('error', error);
      }
    currentMessage = emptyMessage();
    return true;
  };
  parseBuffer = function () {
    var madeProgress;
    madeProgress = true;
    return function (accum$) {
      while (madeProgress) {
        accum$.push(madeProgress = !(null != currentMessage.headers) ? parseHeaders() : parseBody());
      }
      return accum$;
    }.call(this, []);
  };
  stream.on('data', function (chunk) {
    buffer += chunk;
    return parseBuffer(buffer);
  });
  return emitter;
};
callbackWrapper = function () {
  var callbackBySeq, lastSeq, unwrapCallback, wrapCallback;
  callbackBySeq = {};
  lastSeq = 0;
  wrapCallback = function (cb) {
    callbackBySeq[++lastSeq] = cb;
    return lastSeq;
  };
  unwrapCallback = function (obj) {
    var cache$, cb, ref, refMap, request_seq, success;
    cache$ = obj;
    request_seq = cache$.request_seq;
    success = cache$.success;
    cb = callbackBySeq[request_seq];
    if (success) {
      refMap = {};
      if (Array.isArray(obj.refs))
        for (var i$ = 0, length$ = obj.refs.length; i$ < length$; ++i$) {
          ref = obj.refs[i$];
          refMap[ref.handle] = ref;
        }
      return cb(null, obj.body, refMap);
    } else {
      return cb(new Error('' + obj.message + ' - ' + JSON.stringify(obj)));
    }
  };
  return {
    wrapCallback: wrapCallback,
    unwrapCallback: unwrapCallback
  };
};
module.exports = debugClient = function (debugConnection) {
  var cache$, client, parser, registerEvent, registerRequest, sendRequest, sendString, unwrapCallback, wrapCallback;
  client = new EventEmitter;
  client.running = true;
  debugConnection.setEncoding('utf8');
  cache$ = callbackWrapper();
  wrapCallback = cache$.wrapCallback;
  unwrapCallback = cache$.unwrapCallback;
  parser = debugParser(debugConnection);
  parser.on('parsed:response', function (obj) {
    if (null != obj.running)
      client.running = obj.running;
    return unwrapCallback(obj);
  });
  parser.on('parsed:event', function (obj) {
    var body, cache$1, cache$2, err, event, refs, running, success;
    cache$1 = obj;
    success = cache$1.success;
    running = cache$1.running;
    if (null != running)
      client.running = running;
    cache$2 = obj;
    event = cache$2.event;
    body = cache$2.body;
    refs = cache$2.refs;
    if (typeof client['emit_' + event] === 'function') {
      return client['emit_' + event](body, refs);
    } else {
      err = new Error('Unknown debug event: ' + event);
      return client.emit('error', err);
    }
  });
  sendString = function (data) {
    if (debugConnection.writable) {
      return debugConnection.write('Content-Length: ' + data.length + '\r\n\r\n' + data);
    } else {
      client.emit('error', new Error('Debug connection not writable'));
      return client.emit('close');
    }
  };
  sendRequest = function (command, params, cb) {
    var messageObj;
    messageObj = {
      type: 'request',
      command: command,
      seq: wrapCallback(cb)
    };
    if (Object.keys(params).length > 0)
      messageObj['arguments'] = params;
    return sendString(JSON.stringify(messageObj));
  };
  registerRequest = function (command, mapBody) {
    if (null != mapBody)
      mapBody;
    else
      mapBody = function (refs) {
        return function (b) {
          return b;
        };
      };
    return client[command] = function (params, cb) {
      params = typeof params === 'function' ? (cb = params, {}) : null != params ? params : {};
      return sendRequest(command, params, function (err, body, refs) {
        var reffedMap;
        if (!(null != cb))
          return;
        if (null != body) {
          reffedMap = mapBody(refs);
          if (reffedMap.length === 1) {
            return cb(null, reffedMap(body));
          } else {
            return reffedMap(body, cb);
          }
        } else {
          return cb(err, body);
        }
      });
    };
  };
  registerEvent = function (event, mapBody) {
    if (null != mapBody)
      mapBody;
    else
      mapBody = function (refs) {
        return function (b) {
          return b;
        };
      };
    return client['emit_' + event] = function (body, refs) {
      if (null != body)
        body = mapBody(refs)(body);
      return client.emit(event, body);
    };
  };
  registerEvent('afterCompile', function (refs) {
    return function (param$) {
      var script;
      script = param$.script;
      return mapScript(refs)(script);
    };
  });
  registerEvent('break');
  registerEvent('scriptCollected', function (refs) {
    return function (param$) {
      var script;
      script = param$.script;
      return { scriptId: script.id };
    };
  });
  registerEvent('exception', function (refs) {
    return function (body) {
      return body;
    };
  });
  registerRequest('continue');
  registerRequest('suspend');
  registerRequest('evaluate', mapValue);
  registerRequest('lookup', function (refs) {
    return function (body) {
      var handle, mapper, objMap, ref;
      objMap = {};
      mapper = mapValue(refs);
      for (handle in body) {
        ref = body[handle];
        objMap[handle] = mapper(ref);
      }
      return objMap;
    };
  });
  registerRequest('backtrace', function (refs) {
    return function (param$, cb) {
      var cache$1, frames, fromFrame, tasks, toFrame, totalFrames;
      {
        cache$1 = param$;
        fromFrame = cache$1.fromFrame;
        toFrame = cache$1.toFrame;
        totalFrames = cache$1.totalFrames;
        frames = cache$1.frames;
      }
      tasks = frames.map(function (frame) {
        return function (cb) {
          return client.scopes({ frameNumber: frame.index }, function (err, res) {
            var scope;
            if (null != err)
              return cb(err);
            for (var i$ = 0, length$ = res.scopes.length; i$ < length$; ++i$) {
              scope = res.scopes[i$];
              refs['scope:' + frame.index + ':' + scope.index] = scope;
            }
            return cb();
          });
        };
      });
      return series(tasks, function (err) {
        var callFrames;
        if (null != err)
          return cb(err);
        callFrames = frames.map(mapFrame(refs));
        return cb(null, {
          fromFrame: fromFrame,
          toFrame: toFrame,
          totalFrames: totalFrames,
          callFrames: callFrames
        });
      });
    };
  });
  registerRequest('frame', mapFrame);
  registerRequest('scope', function (refs) {
    return function (scope) {
      refs['value:' + scope.object.ref] = mapValue(refs)(scope.object);
      return mapScope(refs)(scope);
    };
  });
  registerRequest('scopes', function (refs) {
    return function (param$) {
      var cache$1, fromScope, handles, scopes, toScope, totalScopes;
      {
        cache$1 = param$;
        fromScope = cache$1.fromScope;
        toScope = cache$1.toScope;
        totalScopes = cache$1.totalScopes;
        scopes = cache$1.scopes;
      }
      scopes = scopes.map(function (scope) {
        if (null != refs['value:' + scope.object.ref])
          refs['value:' + scope.object.ref];
        else
          refs['value:' + scope.object.ref] = mapValue(refs)(scope.object);
        return mapScope(refs)(scope);
      });
      return {
        fromScope: fromScope,
        toScope: toScope,
        totalScopes: totalScopes,
        scopes: scopes
      };
      handles = scopes.map(function (scope) {
        return null != scope.object.ref ? scope.object.ref : scope.object.handle;
      });
      return client.lookup({
        handles: handles,
        inlineRefs: true
      }, function (err, scopeRefs) {
        var obj, objectId;
        if (null != err)
          return cb(err);
        for (objectId in scopeRefs) {
          obj = scopeRefs[objectId];
          refs['value:' + objectId] = obj;
        }
        scopes = scopes.map(mapScope(refs));
        return cb(null, {
          fromScope: fromScope,
          toScope: toScope,
          totalScopes: totalScopes,
          scopes: scopes
        });
      });
    };
  });
  registerRequest('scripts', function (refs) {
    return function (scripts) {
      return scripts.map(mapScript(refs));
    };
  });
  registerRequest('source');
  registerRequest('setbreakpoint');
  registerRequest('changebreakpoint');
  registerRequest('clearbreakpoint');
  registerRequest('setexceptionbreak');
  registerRequest('v8flags');
  registerRequest('version');
  registerRequest('profile');
  registerRequest('disconnect');
  registerRequest('gc');
  registerRequest('listbreakpoints');
  return client;
};
