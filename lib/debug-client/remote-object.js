// Generated by CoffeeScript 2.0.0-beta5
var ErrorObjectFromMessage, extend, isPrimitiveValue, primitiveTypes, RemoteObject;
extend = require('lodash').extend;
primitiveTypes = {
  undefined: true,
  boolean: true,
  number: true,
  string: true
};
isPrimitiveValue = function (body) {
  return body.type && primitiveTypes[body.type];
};
RemoteObject = function (param$) {
  var cache$, generatePreview, returnByValue;
  {
    cache$ = param$;
    returnByValue = cache$.returnByValue;
    generatePreview = cache$.generatePreview;
  }
  return function (refMap) {
    var parseBody;
    return parseBody = function (body) {
      var _baseObject, _constructorName, _describe, _functionName, _generatePreview, _generateProtoPreview, _resolveReffed, _toString, obj, unnamedPropIndex;
      _resolveReffed = function (o) {
        if (!(null != o))
          return null;
        if (null != o.ref)
          o.ref = o.ref.toString();
        if (null != o.handle)
          o.handle = o.handle.toString();
        if (null != o.ref && !(null != o.handle)) {
          return extend(o, { handle: o.ref }, refMap[o.ref]);
        } else {
          return o;
        }
      };
      _functionName = function (fn) {
        if (!(null != fn))
          return null;
        if (!!fn.inferredName) {
          return fn.inferredName;
        } else {
          return fn.name;
        }
      };
      _constructorName = function (body) {
        var byCtor;
        byCtor = _functionName(_resolveReffed(body.constructorFunction));
        return null != byCtor ? byCtor : null != body.text ? body.text.replace(/^#<(.*)>$/, '$1') : void 0;
      };
      _toString = function (obj) {
        return obj.className;
      };
      _describe = function (obj) {
        var cache$1, className, subtype;
        cache$1 = obj;
        subtype = cache$1.subtype;
        className = cache$1.className;
        switch (subtype) {
        case 'regexp':
          return _toString(obj);
        case 'date':
          return _toString(obj);
        case 'array':
          if (null != body.length) {
            return '' + className + '[' + body.length + ']';
          } else {
            return className;
          }
        default:
          return className;
        }
      };
      _generateProtoPreview = function (obj, preview, propertiesThreshold) {
        return console.log(obj, preview, propertiesThreshold);
      };
      _generatePreview = function (obj) {
        var o, preview, propertiesThreshold;
        preview = {
          lossless: true,
          overflow: false,
          properties: []
        };
        propertiesThreshold = {
          properties: 5,
          indexes: 100
        };
        o = obj;
        while (null != o && o.type !== 'undefined') {
          _generateProtoPreview(o, preview, propertiesThreshold);
          o = _resolveReffed(o.prototypeObject);
        }
        return preview;
      };
      _baseObject = function (body) {
        var length, obj, property;
        _resolveReffed(body);
        obj = { type: body.type };
        if (isPrimitiveValue(obj)) {
          if (obj.type !== 'undefined')
            obj.value = body.value;
          if (obj.type === 'number')
            obj.description = null != obj.value ? obj.value.toString() : 'NaN or Infinity';
        } else if (body.type === 'null') {
          obj.type = 'object';
          obj.subtype = 'null';
          obj.value = null;
        } else if (body.type === 'object' || body.type === 'function' || body.type === 'regexp' || body.type === 'error') {
          obj.objectId = body.handle.toString();
          obj.subtype = function () {
            switch (body.className) {
            case 'Date':
              return 'date';
            case 'RegExp':
              return 'regexp';
            case 'Array':
              return 'array';
            }
          }.call(this);
          if (!(obj.type === 'function'))
            obj.type = 'object';
          obj.className = _constructorName(body);
          obj.description = _describe(obj);
          obj.value = null;
          if (obj.subtype === 'array' && null != body.properties)
            for (var i$ = 0, length$ = body.properties.length; i$ < length$; ++i$) {
              property = body.properties[i$];
              if (property.name === 'length' && null != property.value) {
                length = typeof property.value === 'object' ? property.value.value : property.value;
                obj.description = 'Array[' + length + ']';
                break;
              }
            }
        }
        return obj;
      };
      obj = _baseObject(body);
      if (obj.type === 'object' || obj.type === 'function') {
        if (returnByValue) {
          unnamedPropIndex = 0;
          obj.properties = (null != body.properties ? body.properties : []).map(function (propDescriptor) {
            var name, value;
            name = propDescriptor.name;
            if (name === '')
              name = (unnamedPropIndex++).toString();
            value = _baseObject(propDescriptor);
            return {
              name: name,
              value: value
            };
          });
          obj.value = obj.properties.reduce(function (acc, param$1) {
            var cache$1, name, value;
            {
              cache$1 = param$1;
              name = cache$1.name;
              value = cache$1.value;
            }
            acc[name] = value.value;
            return acc;
          }, {});
          if (obj.subtype === 'array')
            obj.properties = obj.properties.filter(function (prop) {
              return prop.name !== 'length';
            });
        }
        if (generatePreview && obj.type === 'object')
          obj.preview = _generatePreview();
      }
      return obj;
    };
  };
};
ErrorObjectFromMessage = function (param$) {
  var cache$, generatePreview, returnByValue;
  {
    cache$ = param$;
    returnByValue = cache$.returnByValue;
    generatePreview = cache$.generatePreview;
  }
  return function (refMap) {
    return function (msg) {
      var className, match, message, objectId;
      match = msg.match(/^(\w+): (.*)$/);
      if (null != match) {
        className = match[1];
        message = match[2];
        objectId = 'const::' + JSON.stringify({
          message: message,
          type: className
        });
        return {
          type: 'object',
          description: msg,
          className: className,
          objectId: objectId
        };
      } else {
        return {
          type: 'string',
          value: msg
        };
      }
    };
  };
};
module.exports = {
  RemoteObject: RemoteObject,
  ErrorObjectFromMessage: ErrorObjectFromMessage
};
