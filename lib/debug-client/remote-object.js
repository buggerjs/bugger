// Generated by CoffeeScript 2.0.0-beta5
var ErrorObjectFromMessage, extend, isPrimitiveValue, primitiveTypes, RemoteObject;
extend = require('lodash').extend;
primitiveTypes = {
  undefined: true,
  boolean: true,
  number: true,
  string: true
};
isPrimitiveValue = function (body) {
  return body.type && primitiveTypes[body.type];
};
RemoteObject = function (param$) {
  var cache$, generatePreview, returnByValue;
  {
    cache$ = param$;
    returnByValue = cache$.returnByValue;
    generatePreview = cache$.generatePreview;
  }
  return function (refMap) {
    var parseBody;
    return parseBody = function (body) {
      var _constructorName, _describe, _extractLength, _functionName, _generatePreview, _generateProtoPreview, _resolveReffed, _toString, obj, property;
      _resolveReffed = function (o) {
        if (!(null != o))
          return null;
        if (null != o.ref)
          o.ref = o.ref.toString();
        if (null != o.handle)
          o.handle = o.handle.toString();
        if (null != o.ref && !(null != o.handle)) {
          return extend(o, { handle: o.ref }, refMap[o.ref]);
        } else {
          return o;
        }
      };
      _functionName = function (fn) {
        if (!(null != fn))
          return null;
        if (!!fn.inferredName) {
          return fn.inferredName;
        } else {
          return fn.name;
        }
      };
      _constructorName = function () {
        var byCtor;
        byCtor = _functionName(_resolveReffed(body.constructorFunction));
        return null != byCtor ? byCtor : null != body.text ? body.text.replace(/^#<(.*)>$/, '$1') : void 0;
      };
      _toString = function (obj) {
        return obj.className;
      };
      _extractLength = function (body) {
        var cache$1, prop;
        if (null != body.length)
          return body.length;
        for (var i$ = 0, length$ = body.properties.length; i$ < length$; ++i$) {
          prop = body.properties[i$];
          if (prop.name === 'length') {
            console.log(prop);
            if (null != prop.value)
              return prop.value;
            if (null != prop.ref)
              return null != (cache$1 = refMap[prop.ref.toString()]) ? cache$1.value : void 0;
            return null;
          } else {
            continue;
          }
        }
        return null;
      };
      _describe = function (obj) {
        var cache$1, className, subtype;
        cache$1 = obj;
        subtype = cache$1.subtype;
        className = cache$1.className;
        switch (subtype) {
        case 'regexp':
          return _toString(obj);
        case 'date':
          return _toString(obj);
        case 'array':
          if (null != body.length) {
            return '' + className + '[' + body.length + ']';
          } else {
            return className;
          }
        default:
          return className;
        }
      };
      _generateProtoPreview = function (obj, preview, propertiesThreshold) {
        return console.log(obj, preview, propertiesThreshold);
      };
      _generatePreview = function (obj) {
        var o, preview, propertiesThreshold;
        preview = {
          lossless: true,
          overflow: false,
          properties: []
        };
        propertiesThreshold = {
          properties: 5,
          indexes: 100
        };
        o = obj;
        while (null != o && o.type !== 'undefined') {
          _generateProtoPreview(o, preview, propertiesThreshold);
          o = _resolveReffed(o.prototypeObject);
        }
        return preview;
      };
      _resolveReffed(body);
      obj = { type: body.type };
      if (isPrimitiveValue(obj)) {
        if (obj.type !== 'undefined')
          obj.value = body.value;
        if (obj.type === 'number')
          obj.description = null != obj.value ? obj.value.toString() : 'NaN or Infinity';
      } else if (body.type === 'null') {
        obj.type = 'object';
        obj.subtype = 'null';
        obj.value = null;
      } else if (body.type === 'object' || body.type === 'function' || body.type === 'regexp') {
        obj.objectId = body.handle.toString();
        obj.subtype = function () {
          switch (body.className) {
          case 'Date':
            return 'date';
          case 'RegExp':
            return 'regexp';
          case 'Array':
            return 'array';
          }
        }.call(this);
        if (!(obj.type === 'function'))
          obj.type = 'object';
        obj.className = _constructorName();
        obj.description = _describe(obj);
        obj.value = null;
        if (obj.subtype === 'array' && null != body.properties)
          for (var i$ = 0, length$ = body.properties.length; i$ < length$; ++i$) {
            property = body.properties[i$];
            if (property.name === 'length' && null != property.value) {
              obj.description = 'Array[' + property.value.value + ']';
              break;
            }
          }
        if (returnByValue)
          obj.value = (null != body.properties ? body.properties : []).reduce(function (acc, propDescriptor) {
            var name, propObj;
            name = propDescriptor.name;
            propObj = parseBody(propDescriptor);
            acc[name] = propObj.value;
            return acc;
          }, {});
        if (generatePreview && obj.type === 'object')
          obj.preview = _generatePreview();
      } else {
        obj.objectId = body.handle;
      }
      return obj;
    };
  };
};
ErrorObjectFromMessage = function (param$) {
  var cache$, generatePreview, returnByValue;
  {
    cache$ = param$;
    returnByValue = cache$.returnByValue;
    generatePreview = cache$.generatePreview;
  }
  return function (refMap) {
    return function (msg) {
      var className, match, message, objectId;
      match = msg.match(/^(\w+): (.*)$/);
      if (null != match) {
        className = match[1];
        message = match[2];
        objectId = 'const::' + JSON.stringify({
          message: message,
          type: className
        });
        return {
          type: 'object',
          description: msg,
          className: className,
          objectId: objectId
        };
      } else {
        return {
          type: 'string',
          value: message
        };
      }
    };
  };
};
module.exports = {
  RemoteObject: RemoteObject,
  ErrorObjectFromMessage: ErrorObjectFromMessage
};
