// Generated by CoffeeScript 2.0.0-beta4
var _, debug, expressionToHandle, handleToExpression, languageMode, logAndReturn, LOOKUP_TIMEOUT, prepareEvaluation, refToObject, RuntimeAgent, throwErr, toJSONValue, wrapperObject;
_ = require('underscore');
prepareEvaluation = require('../lang').prepareEvaluation;
debug = require('../debug-client');
cache$ = require('../wrap_and_map');
toJSONValue = cache$.toJSONValue;
wrapperObject = cache$.wrapperObject;
logAndReturn = cache$.logAndReturn;
throwErr = cache$.throwErr;
expressionToHandle = cache$.expressionToHandle;
handleToExpression = cache$.handleToExpression;
refToObject = cache$.refToObject;
LOOKUP_TIMEOUT = 2500;
languageMode = 'js';
module.exports = RuntimeAgent = {
  evaluate: function (options, cb, channel) {
    var args, cache$1, cmd, commandMode, doNotPauseOnExceptions, expression, includeCommandLineAPI, m, objectGroup, parseError, returnByValue;
    cache$1 = options;
    expression = cache$1.expression;
    objectGroup = cache$1.objectGroup;
    includeCommandLineAPI = cache$1.includeCommandLineAPI;
    doNotPauseOnExceptions = cache$1.doNotPauseOnExceptions;
    returnByValue = cache$1.returnByValue;
    commandMode = /^:(\w+)$/;
    if (m = expression.match(commandMode)) {
      cmd = m[1];
      if (cmd === 'js' || cmd === 'coffee') {
        languageMode = cmd;
        return channel.console('Switched input language to ' + cmd, 'info');
      } else {
        return channel.console('Unknown command: ' + m[1], 'error');
      }
    }
    try {
      expression = prepareEvaluation(languageMode, expression);
    } catch (e$) {
      parseError = e$;
      console.log(expression, parseError);
      return throwErr(cb, parseError.toString());
    }
    args = {
      expression: expression,
      disable_break: doNotPauseOnExceptions,
      global: true,
      maxStringLength: 1e5
    };
    console.log(args);
    return debug.request('evaluate', { 'arguments': args }, function (result) {
      var resolvedObj;
      if (result.success) {
        result.body.handle = expressionToHandle(expression);
        resolvedObj = refToObject(result.body);
        if (returnByValue && !(null != resolvedObj.value))
          resolvedObj.value = toJSONValue(result.body, result.refs);
        console.log('Runtime.evaluate ' + expression);
        return cb(null, resolvedObj);
      } else {
        console.log(result);
        throwErr(cb, result.message);
        return cb(null, result.message, true);
      }
    });
  },
  callFunctionOn: function (options, cb) {
    var additional_context, args, cache$1, cache$2, disable_break, expression, frame, functionDeclaration, objectId, ref, returnByValue, scope;
    cache$1 = options;
    objectId = cache$1.objectId;
    functionDeclaration = cache$1.functionDeclaration;
    returnByValue = cache$1.returnByValue;
    args = options['arguments'];
    cache$2 = objectId.split(':');
    frame = cache$2[0];
    scope = cache$2[1];
    ref = cache$2[2];
    console.log('Call on ', objectId, 'returnByValue', returnByValue);
    expression = '(' + functionDeclaration + ').apply(' + handleToExpression(ref) + ', ' + JSON.stringify(args) + ');';
    disable_break = true;
    additional_context = [];
    return debug.request('evaluate', {
      'arguments': {
        expression: expression,
        disable_break: disable_break,
        additional_context: additional_context,
        global: true
      }
    }, function (result) {
      var resolvedObj;
      if (result.success) {
        resolvedObj = refToObject(result.body);
        if (returnByValue && !(null != resolvedObj.value))
          resolvedObj.value = toJSONValue(result.body, result.refs);
        return cb(null, resolvedObj);
      } else {
        return cb(result.message);
      }
    });
  },
  getProperties: function (param$, cb) {
    var cache$1, cache$2, disable_break, expression, frame, functionDeclaration, getOwnProperties, handle, handles, objectId, ownProperties, ref, scope, timeout;
    {
      cache$1 = param$;
      objectId = cache$1.objectId;
      ownProperties = cache$1.ownProperties;
    }
    cache$2 = objectId.split(':');
    frame = cache$2[0];
    scope = cache$2[1];
    ref = cache$2[2];
    console.log('[Runtime.getProperties] Object id: ' + objectId);
    if (ref === 'backtrace') {
      return debug.request('scope', {
        'arguments': {
          number: scope,
          frameNumber: parseInt(frame),
          inlineRefs: true
        }
      }, function (msg) {
        var refs;
        if (msg.success) {
          refs = {};
          if (msg.refs && Array.isArray(msg.refs))
            msg.refs.forEach(function (r) {
              return refs[r.handle] = r;
            });
          return cb(null, msg.body.object.properties.map(function (p) {
            var r;
            r = refs[p.value.ref];
            return {
              name: p.name,
              value: refToObject(r)
            };
          }));
        } else {
          return console.log('[debug.error] scope: ', msg);
        }
      });
    } else {
      handle = parseInt(ref, 10);
      if (isNaN(handle)) {
        getOwnProperties = function () {
          var name, props;
          props = {};
          for (var cache$3 = Object.getOwnPropertyNames(this), i$ = 0, length$ = cache$3.length; i$ < length$; ++i$) {
            name = cache$3[i$];
            props[name] = this[name];
          }
          return props;
        };
        functionDeclaration = getOwnProperties.toString();
        expression = '(' + functionDeclaration + ').apply(' + handleToExpression(ref) + ', []);';
        disable_break = true;
        return debug.request('evaluate', {
          'arguments': {
            expression: expression,
            disable_break: disable_break,
            global: true
          }
        }, function (result) {
          var props, refMap;
          if (result.success) {
            refMap = {};
            result.refs.forEach(function (refDesc) {
              return refMap[refDesc.handle] = refDesc;
            });
            props = result.body.properties.map(function (pDesc) {
              var propObj;
              propObj = _.defaults({ handle: '' + ref + '[' + JSON.stringify(pDesc.name) + ']' }, refMap[pDesc.ref]);
              return {
                name: pDesc.name,
                value: refToObject(propObj)
              };
            });
            return cb(null, props);
          } else {
            console.log(result);
            return cb(result.message);
          }
        });
      } else {
        timeout = setTimeout(function () {
          var seq;
          cb(null, [{
              name: 'sorry',
              value: wrapperObject('string', 'lookup timed out', false, 0, 0, 0)
            }]);
          return seq = 0;
        }, LOOKUP_TIMEOUT);
        handles = [handle];
        return debug.request('lookup', {
          'arguments': {
            handles: handles,
            includeSource: false
          }
        }, function (msg) {
          var obj, objProps, props, proto, r, refs;
          clearTimeout(timeout);
          if (msg.success) {
            obj = msg.body[handle];
            if (!(null != obj.properties))
              return cb(null, null);
            refs = {};
            props = [];
            if (msg.refs && Array.isArray(msg.refs)) {
              objProps = obj.properties;
              proto = obj.protoObject;
              for (var i$ = 0, length$ = msg.refs.length; i$ < length$; ++i$) {
                r = msg.refs[i$];
                refs[r.handle] = r;
              }
              props = objProps.map(function (p) {
                r = refs[p.ref];
                return {
                  name: String(p.name),
                  value: refToObject(r)
                };
              });
              if (proto)
                props.push({
                  name: '__proto__',
                  value: refToObject(refs[proto.ref])
                });
            }
            return cb(null, props);
          } else {
            return console.log('[error] Runtime#getProperties', msg);
          }
        });
      }
    }
  }
};
