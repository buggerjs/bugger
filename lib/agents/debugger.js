// Generated by CoffeeScript 2.0.0-beta4
var debug, DebuggerAgent, expressionToHandle, refToObject, throwErr;
debug = require('../debug-client');
cache$ = require('../wrap_and_map');
refToObject = cache$.refToObject;
expressionToHandle = cache$.expressionToHandle;
throwErr = cache$.throwErr;
module.exports = DebuggerAgent = {
  enable: function (cb) {
    console.log('Debbuger#enable');
    return cb(null, true);
  },
  disable: function (cb) {
    console.log('Debbuger#disable');
    return cb(null, true);
  },
  setPauseOnExceptions: function (param$, cb) {
    var state;
    state = param$.state;
    console.log('Debugger#setPauseOnExceptions', arguments[0]);
    return cb(null, true);
  },
  setBreakpointsActive: function (param$, cb) {
    var active;
    active = param$.active;
    console.log('Debugger#setBreakpointsActive', arguments[0]);
    return cb(null, true);
  },
  removeBreakpoint: function (param$, cb) {
    var breakpointId;
    breakpointId = param$.breakpointId;
    return debug.request('clearbreakpoint', { 'arguments': { breakpoint: breakpointId } }, function (msg) {
      var id;
      for (id in debug.breakpoints) {
        if (debug.breakpoints[id] === breakpointId) {
          delete debug.breakpoints[id];
          break;
        }
      }
      return cb(null);
    });
  },
  setBreakpointByUrl: function (param$, cb) {
    var args, bp, cache$1, columnNumber, condition, enabled, lineNumber, sourceID, url;
    {
      cache$1 = param$;
      lineNumber = cache$1.lineNumber;
      url = cache$1.url;
      columnNumber = cache$1.columnNumber;
      condition = cache$1.condition;
    }
    enabled = true;
    sourceID = debug.sourceUrls[url];
    if (bp = debug.breakpoints[sourceID + ':' + lineNumber]) {
      args = {
        'arguments': {
          breakpoint: bp.breakpointId,
          enabled: enabled,
          condition: condition
        }
      };
      return debug.request('changebreakpoint', args, function (msg) {
        bp.enabled = enabled;
        bp.condition = condition;
        return cb(null, bp.breakpointId, bp.locations);
      });
    } else {
      args = {
        type: 'scriptId',
        target: sourceID,
        line: lineNumber,
        enabled: enabled,
        condition: condition
      };
      return debug.request('setbreakpoint', { 'arguments': args }, function (msg) {
        var b;
        if (msg.success) {
          b = msg.body;
          bp = debug.breakpoints[b.script_id + ':' + b.line] = {
            sourceID: b.script_id,
            url: debug.sourceIDs[b.script_id].url,
            line: b.line,
            breakpointId: b.breakpoint.toString(),
            locations: b.actual_locations.map(function (l) {
              return {
                scriptId: l.script_id.toString(),
                lineNumber: l.line,
                columnNumber: l.column
              };
            }),
            enabled: enabled,
            condition: condition
          };
          return cb(null, bp.breakpointId, bp.locations);
        }
      });
    }
  },
  pause: function (cb) {
    console.log('Debugger#pause');
    return debug.request('suspend', {}, function (msg) {
      return debug.emit('break');
    });
  },
  resume: function (cb) {
    console.log('Debugger#resume');
    return debug.request('continue', {}, function (msg) {
      debug.emit('resumed');
      return cb(null, true);
    });
  },
  stepOver: function (cb) {
    return debug.request('continue', { 'arguments': { stepaction: 'next' } }, function (msg) {
      debug.emit('resumed');
      return cb(null, true);
    });
  },
  stepInto: function (cb) {
    return debug.request('continue', { 'arguments': { stepaction: 'in' } }, function (msg) {
      debug.emit('resumed');
      return cb(null, true);
    });
  },
  stepOutOfFunction: function (cb) {
    return debug.request('continue', { 'arguments': { stepaction: 'out' } }, function (msg) {
      debug.emit('resumed');
      return cb(null, true);
    });
  },
  getScriptSource: function (param$, cb) {
    var args, scriptId;
    scriptId = param$.scriptId;
    args = {
      'arguments': {
        includeSource: true,
        types: 4,
        ids: [scriptId]
      }
    };
    return debug.request('scripts', args, function (msg) {
      return cb(null, msg.body[0].source);
    });
  },
  getFunctionDetails: function (param$, cb) {
    var objectId;
    objectId = param$.objectId;
  },
  evaluateOnCallFrame: function (options, cb) {
    var args, cache$1, cache$2, callFrameId, doNotPauseOnExceptionsAndMuteConsole, expression, generatePreview, includeCommandLineAPI, objectGroup, returnByValue;
    cache$1 = options;
    callFrameId = cache$1.callFrameId;
    expression = cache$1.expression;
    objectGroup = cache$1.objectGroup;
    includeCommandLineAPI = cache$1.includeCommandLineAPI;
    cache$2 = options;
    doNotPauseOnExceptionsAndMuteConsole = cache$2.doNotPauseOnExceptionsAndMuteConsole;
    returnByValue = cache$2.returnByValue;
    generatePreview = cache$2.generatePreview;
    args = {
      expression: expression,
      disable_break: doNotPauseOnExceptionsAndMuteConsole,
      global: false,
      maxStringLength: 1e5
    };
    if (null != callFrameId)
      args.frame = callFrameId;
    return debug.request('evaluate', { 'arguments': args }, function (result) {
      var resolvedObj;
      if (result.success) {
        result.body.handle = expressionToHandle(expression);
        resolvedObj = refToObject(result.body, null != callFrameId ? callFrameId : 0);
        if (returnByValue && !(null != resolvedObj.value))
          resolvedObj.value = toJSONValue(result.body, result.refs);
        return cb(null, resolvedObj);
      } else {
        return throwErr(cb, result.message + JSON.stringify(args));
      }
    });
  }
};
