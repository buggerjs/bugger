// Generated by CoffeeScript 2.0.0-beta4
var _, _probeCallbacks, commands, EntryScriptWrapper, EventEmitter, timelineInterval;
EventEmitter = require('events').EventEmitter;
_ = require('underscore');
timelineInterval = false;
_probeCallbacks = [];
commands = {
  startScript: function (param$) {
    var brk, cache$, entryScript, loadProbes, probes, requireScript;
    {
      cache$ = param$;
      entryScript = cache$.entryScript;
      brk = cache$.brk;
      probes = cache$.probes;
    }
    requireScript = require('../lang').requireScript;
    loadProbes = require('../probes').loadProbes;
    loadProbes(null != probes ? probes : ['network']);
    return requireScript(entryScript, brk === true);
  },
  'Timeline.start': function (param$) {
    var maxCallStackDepth;
    maxCallStackDepth = param$.maxCallStackDepth;
    if (!timelineInterval)
      return timelineInterval = setInterval(function () {
        return process.send({
          method: 'Timeline.eventRecorded',
          record: {
            type: 'Time',
            usedHeapSize: process.memoryUsage().heapUsed,
            startTime: new Date().getTime()
          }
        });
      }, 1e3);
  },
  'Timeline.stop': function () {
    if (timelineInterval)
      return clearInterval(timelineInterval);
  }
};
if (!(null != module.parent)) {
  process.debugPort = process.env.BUGGER_DEBUG_PORT;
  process.kill(process.pid, 'SIGUSR1');
  process.on('message', function (message) {
    if (null != commands[message.method]) {
      return commands[message.method](message);
    } else {
      return console.error('[bugger] Unknown message from parent: ' + message.method, message);
    }
  });
  process.on('uncaughtException', function (error) {
    return process.send({
      method: 'uncaughtException',
      error: {
        name: error.name,
        message: error.message,
        stack: error.stack,
        method: error.method,
        meta: error.meta
      }
    });
  });
  setTimeout(function () {
  }, 5);
  process.send({ method: 'childReady' });
}
EntryScriptWrapper = function (super$) {
  extends$(EntryScriptWrapper, super$);
  function EntryScriptWrapper() {
  }
  EntryScriptWrapper.prototype.delegate = function (method, params, cb) {
    var callbackRef;
    callbackRef = _probeCallbacks.length;
    _probeCallbacks[callbackRef] = cb;
    return module.exports.proc.send(_.extend({
      method: method,
      callbackRef: callbackRef
    }, params));
  };
  EntryScriptWrapper.prototype.forkEntryScript = function (param$, cb) {
    var backChannelHandlers, brk, cache$, cache$1, debugClient, debugPort, entryScript, entryScriptProc, env, fork, net, networkAgent, scriptArgs, spawn, startupFailedTimeout;
    {
      cache$ = param$;
      entryScript = cache$.entryScript;
      scriptArgs = cache$.scriptArgs;
      debugPort = cache$.debugPort;
      brk = cache$.brk;
    }
    cache$1 = require('child_process');
    spawn = cache$1.spawn;
    fork = cache$1.fork;
    net = require('net');
    networkAgent = require('../agents/network');
    debugClient = require('../debug-client');
    env = _.defaults({ BUGGER_DEBUG_PORT: debugPort }, process.env);
    entryScriptProc = fork(module.filename, scriptArgs, {
      env: env,
      silent: true
    });
    startupFailedTimeout = setTimeout(function () {
      throw new Error('Process for entry script failed to start');
    }, 1e3);
    module.exports.proc = entryScriptProc;
    backChannelHandlers = {
      childReady: function () {
        var debugConnection;
        if (startupFailedTimeout)
          clearTimeout(startupFailedTimeout);
        startupFailedTimeout = true;
        return debugConnection = net.connect(debugPort, function () {
          debugClient.init({ connection: debugConnection });
          return setTimeout(function () {
            return debugClient.request('continue', {}, function () {
              entryScriptProc.send({
                method: 'startScript',
                entryScript: entryScript,
                brk: brk
              });
              return cb(debugClient);
            });
          }, 1);
        });
      },
      cacheResponseContent: function () {
        return networkAgent.cacheResponseContent.apply(networkAgent, arguments);
      },
      refCallback: function (param$1) {
        var args, cache$2, callbackRef;
        {
          cache$2 = param$1;
          callbackRef = cache$2.callbackRef;
          args = cache$2.args;
        }
        return _probeCallbacks[callbackRef].apply(null, args);
      },
      uncaughtException: function (param$1) {
        var error;
        error = param$1.error;
        return console.log('Uncaught exception in child:', error);
      }
    };
    return entryScriptProc.on('message', function (message) {
      if (null != backChannelHandlers[message.method]) {
        return backChannelHandlers[message.method](message);
      } else {
        return module.exports.emit('message', message);
      }
    });
  };
  return EntryScriptWrapper;
}(EventEmitter);
module.exports = new EntryScriptWrapper;
function isOwn$(o, p) {
  return {}.hasOwnProperty.call(o, p);
}
function extends$(child, parent) {
  var key;
  for (key in parent)
    if (isOwn$(parent, key))
      child[key] = parent[key];
  function ctor() {
    this.constructor = child;
  }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor;
  child.__super__ = parent.prototype;
  return child;
}
